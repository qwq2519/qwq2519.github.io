---
title: redis源码阅读-数据存储与管理-内存高效数据结构
date: 2025-09-08 23:40:11
tags:
  - redis
---

本文介绍redis几种内存高效存储的数据结构，适合数据量小的集合。当数据量增大达到一定阈值，这些数据结构会自动转换为更通用的数据结构。

这些数据结构采用了紧凑的二进制编码，避免了指针开销。

虽然操作复杂性高）

![image-20250909124345482](./../images/image-20250909124345482.png)

![image-20250909124504467](./../images/image-20250909124504467.png)

# Ziplist

压缩的双向链表，能存储字符串和整数。

后来被listpack取代了。

![image-20250909125102157](./../images/image-20250909125102157.png)

![image-20250909125252521](./../images/image-20250909125252521.png)

- 级联更新：当前entry的prelen字段记录上一个entry的长度。当prelen采用变长编码，一个entry的prelen的占用空间发生变化，可能导致后续所有entry的prelen占用空间发生变化，导致所有entry更新。但是比较极端。
- 安全检查
- 整数优化：超小整数直接编码到编码本身里面。

# Listpack

ziplist的优化，主要是为了解决级联更新。

![image-20250909130024008](./../images/image-20250909130024008.png)

采用backlen反向编码，高效进行反向遍历

![image-20250909130240637](./../images/image-20250909130240637.png)

# Intset

自动排序数组，自动编码升级

![image-20250909130447175](./../images/image-20250909130447175.png)

- 自动升级：当插入的new value需要更大的编码，整个intset都会升级
  - 判断所需的编码
  - 分配内存
  - 复制，从后往前复制避免覆写（如果数组起始地址没有变，只是扩长，那么就必须这样）
  - 插入new value在合适的位置
  - 更新编码，长度字段。
- 二分查找：这个整数集合是有序的
- 内存高效：直接用数组存，没有指针
- 字节序：通过memrev16ifbe()函数进行处理

![image-20250909131216246](./../images/image-20250909131216246.png)

# Zipmap

提供内存高效String -> String  的映射，为了小哈希表设计。

带有长度前缀的线性布局。

![image-20250909131456301](./../images/image-20250909131456301.png)

- 线性查找：但是对于小集合，缓存友好
- 空闲空间管理：value可以有尾随的空闲空间，减少内存分配次数。
- 长度编码：
- 内存高效：无指针，线性连续内存布局

![image-20250909131935528](./../images/image-20250909131935528.png)

# 内存优化策略



![image-20250909132116465](./../images/image-20250909132116465.png)

![image-20250909132109202](./../images/image-20250909132109202.png)

并且有校验机制保证数据完整性

![image-20250909132157886](./../images/image-20250909132157886.png)

- 边界验证
- 编码验证
- 头信息中的大小验证
- 损坏测试：有测试可以检测错误的数据
