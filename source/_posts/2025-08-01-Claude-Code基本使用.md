---
title: Claude Code基本使用
date: 2025-08-01 16:34:22
tags: 
  - AI
  - 工具
---

# 参考文档

[CC官方中文文档](https://docs.anthropic.com/zh-CN/docs/claude-code/overview)



# 安装

去上面的文档找，很多很详细了。

值得一提，安装git后，要用新开一个CC专门的环境变量指向git的bash.exe。



# 接入IDE

可以在vs或者idea中安装插件。

然后ide中可以看到一个CC图标，点击就会打开IDE内嵌终端，然后可以输入/ide 进入CC的ide模式，这样CC对文件的修改可以在IDE的图形化界面中看到

# 简单使用

## 命令

### claude

| 命令 | 描述 | 示例 |
| ---- | ---- | ---- |
| `claude` | 启动交互式 REPL | `claude` |
| `claude "query"` | 使用初始提示启动 REPL | `claude "explain this project"` |
| `claude -p "query"` | 通过 SDK 查询，然后退出 | `claude -p "explain this function"` |
| `cat file | claude -p "query"` | 处理管道内容 | `cat logs.txt | claude -p "explain"` |
| `claude -c` | 继续最近的对话 | `claude -c` | |


### add-dir

​	在使用Claude Code的时候，一般都会首先添加工作目录。

```
/add-dir <工作目录>
```



一个项目如果有多个需求，可以通过多个工作目录或者多个分支来进行并行开发？（没试过）

### init

```
/init 
```

​	初始化项目记忆指南，完成项目分析初始化。

​	在创建工作目录后，使用初始化工具对该目录下的项目进行初始化分析，生成一份CLAUDE.md文档。这个文档的作用是建立上下文， 通常包含项目结构摘要、主要模块说明、依赖列表等内容，让Claude Code理解当前项目的目标和结构

- 你可以手动设置代码风格和一些规则、设置Claude Code的角色。
- 也可以在进行初始化之后通过自然语言输入让其修改该初始化说明文档，进而实现所需的设定。比如询问 “请列出项目架构的关键部分写入 CLAUDE.md” 等

​	完成后，将 CLAUDE.md 保存（甚至提交进仓库共享给团队）。之后每次在该项目目录启动Claude Code，它都会首先读取 CLAUDE.md，拥有持久的项目信息。



与AI对话，我们都知道系统prompt很重要，会持续影响AI。这个ClAUDE.md也是一样的作用。



### help

查看命令列表

```
/help
```

### clear	

```
/clear
```

​	用于清除当前会话的对话历史，使 Claude 忘记之前的所有对话内容。执行后，相当于开启一个新会话，但不会退出 Claude Code 界面。

​	当对话持续很久、上下文累积过多时，可以使用 /clear 来重置上下文窗口，保持思路清晰。

​	在完成一个独立任务后，开始新任务前执行 /clear，Claude 将从空上下文开始理解你的下一指令。这在任务切换时非常有用，可以避免旧话题干扰新需求。

​	此外，当Claude的回答出现偏离正轨或上下文混乱时，/clear 可以一键“重启”对话。

### compact 

```
/compact [instructions]
```

​	压缩对话内容。此命令会将当前对话历史总结压缩，并以该摘要作为新对话的开场上下文。可选的 instructions 参数允许你指定压缩时的侧重点，例如 /compact "保留尚未解决的问题" 会让 Claude 在总结时侧重未解决问题部分。

​	当会话长度接近模型上下文长度上限时，/compact 可以延续长对话。Claude 会将已有对话自动总结为更短的内容，从而释放大量上下文令牌供后续交流使用。

​	这类似于有个 AI 秘书在会议途中帮你记录会议纪要，确保你们不会因为对话太长而“忘记”前情。

​	与 /clear 不同，/compact 保留了上下文的精华——在新会话中Claude仍可以参考之前对话的摘要继续讨论。

### memory

```
/memory
```


​	编辑会话记忆文件,直接打开并编辑当前项目的持久记忆文件 CLAUDE.md（或用户级别的全局记忆文件），方便查看和修改 Claude 的“长期记忆”。你也可以通过这个命令向 CLAUDE.md 添加或移除内容。

​	CLAUDE.md 是 Claude Code 用于初始化上下文的指南文件，通常包含项目简介、架构要点、代码惯例等。通过 /memory 命令，你可以随时更新该文件的内容

​	比如在初始化项目后发现 CLAUDE.md 漏掉了一些关键业务术语解释，可以输入 /memory 打开文件，在其中添加术语解释列表并保存。保存退出后，可以 /clear 然后开始新会话，Claude 将自动参照更新后的 CLAUDE.md 来回答问题，减少对术语的误解。



### status

```
/status
```

显示当前 Claude Code 会话和系统状态，包括工作目录、登录账户、所用模型、加载的项目记忆等。这是一条只读命令，不会更改任何设置。

当你需要确认当前环境时（例如切换目录后不确定Claude是否跟随了新项目，或刚切换模型后想验证当前模型名），/status 可以立刻给出答案。

它也是排查问题的起点：如果Claude行为异常，先看一下 /status 是否仍指向正确的路径和模型，是否有正确加载 CLAUDE.md 等。

### cost

```
/cost
```

显示当前会话的令牌使用量统计，包括提示和回答分别用了多少 token，以及预估的 API 消耗费用。这对掌控 Claude Code 的使用成本非常有帮助。

如果你使用按量计费的API密钥或免费额度，随时关注对话的 token 消耗情况是个好习惯。执行 /cost 可以让你了解目前这场对话累计用了多少 token，并据此估算花费。

在长时间编程会话或密集代码生成功能中，偶尔检查 /cost 有助于及时止损：发现token飙升可以选择提问更具体、压缩上下文等节约开销。

另外，当你打算结束当天工作时，可以用 /cost 获取会话用量总结，核对是否在预算之内。

### config


```
/config
```

可交互式查看和修改 Claude Code 配置参数。

执行命令会显示配置菜单，你可以根据提示修改设置，例如启用/禁用自动压缩、设置主题、切换编辑模式等。部分配置也支持通过子命令直接设置，比如 /config set autocompact off 等。

Claude Code 提供许多可定制选项，通过 /config 你可以根据个人习惯进行调整。

- Autocompact（自动压缩）默认开启以防止上下文溢出，通常建议保持开启；
- 待办事项（to-do）功能可以让Claude Code在长任务中列步骤，你可在配置中启用/停用；
- verbose输出用于调试，可通过 /config 打开，当需要看Claude内部推理步骤时很有用（对应快捷键 Ctrl+R 切换verbose模式）；
- 还有主题配色、通知方式（如终端铃声提醒Claude完成思考）、编辑模式等。


总之，/config 是你的个性化Claude控制面板。


### model

```
/model [model_name
```


切换AI模型版本,不带参数时通常会显示当前使用的模型，并提示可选模型列表；指定参数则可切换Claude所用的AI模型。

Claude Code 常用的模型代号包括 Sonnet（较快、上下文较短）和 Opus（较慢但能力更强、上下文长度更大）等，或具体版本如 claude-4-100k 等。

根据任务需要选择合适的模型，能在速度和质量间取得平衡。默认情况下Claude Code启动用的是较快的模型（截至2025年一般是 Sonnet 系列，如 claude-3.7-sonnet-xxxx）。

当你需要更深入的分析、更大的上下文或更高准确度时，可以通过 /model opus 切换到能力更强的模型。

复杂架构设计讨论、批量代码重构等场景，Opus模型会表现更佳。而在简单问答或需要快速响应的场景下，继续使用Sonnet模型更高效。/model 让你动态调整AI助手的大脑，以匹配任务要求。

### doctor

```
/doctor
```

环境健康检查,执行后Claude Code会检查当前安装环境的健康状态，验证所需依赖和权限是否正确配置，并报告潜在问题。

当Claude Code行为异常（比如无法读取文件、工具调用总是失败等），/doctor 是排查问题的第一步。它会自动检查：Anthropic API连通性、已登录账户有效性、必需的依赖（git、GitHub CLI、ripgrep等）是否安装、Claude Code所需的文件权限是否授予等等。检查完后会输出一份报告，指出哪些项目通过，哪些存在问题,有了这些信息，你可以据此修复环境，然后重试之前的操作。

### resume

可以查看历史聊天记录并进入


## 快捷键

使用关键词 like Shift+Tab 切换“计划模式”和“自动编辑模式”，默认模式是所有指令都需要手动确认。

计划模式就是不会写代码，会给你提供规划任务的。



使用 bash 快捷命令 ! 来运行单条命令




## 使用工作流

以上命令可以串联起来，形成流畅的工作流。下面通过一个实际开发流程，展示如何组合命令完成复杂任务：

场景： 你接手一个新项目，需要先熟悉代码，再开发新功能，最后提交PR并做审查。使用Claude Code，你计划如下操作：

**初始化项目记忆：**进入项目目录，启动 Claude Code 后，首先运行 /init 创建 CLAUDE.md 项目指南。这样Claude对项目有基本认识。接着你询问 “> summarize this project”，Claude很快给出代码库概览，得益于刚生成的记忆文件提供的上下文。

**配置模型与权限：**你发现默认模型对架构问题思考稍显吃力，于是输入 /model opus 切换到更强大的模型，以更好理解复杂代码结构。

**编写代码与反馈：**在Claude的协助下，你开始编写新功能代码。Claude 直接在终端提议修改文件并执行了编辑。过程中会话变长，你适时使用 /compact "保留新功能相关讨论" 将上下文压缩，让Claude聚焦当前任务。当一个模块修改完成，你又用 /clear 清理对话历史，针对下一个模块重新开始，确保Claude不被上一部分内容干扰。

**代码功能完善**

**代码性能分析和优化**

通过以上步骤可以看到，Claude Code 的斜杠命令配合自然语言输入，可以贯穿开发全流程：从环境准备、到编码调试、再到功能完善，以及最后的性能分析和优化，每一步都有相应的操作支持。

灵活地组合运用命令和自然语言输入，能把重复繁杂的操作交给AI处理，开发者则专注于高层逻辑，实现真正的人机协作高效编程。



一个简单的工作流就是：

- 建立初始CLAUDE.md
- 持续对话，直到上下文接近上限，使用压缩指令续命
- 对话到里程碑时，要求CC将结果存入CLAUDE.md
- 继续对话，循环。





[常见工作流程 - Anthropic](https://docs.anthropic.com/zh-CN/docs/claude-code/common-workflows)





## Ccusage 工具

该工具能比CC自带的cost指令显示更多的token消耗

```
npm install -g ccusage
```



```plaintext
# 基本用法
ccusage           # 显示每日报告（默认）
ccusage daily     # 每日Token用量与费用
ccusage monthly   # 月度报告
ccusage session   # 按会话统计用量
ccusage blocks    # 5小时计费窗口

# 实时监控
ccusage blocks --live  # 实时用量仪表盘

# 筛选与选项
ccusage daily --since 20250525 --until 20250530  # 指定时间段用量报告
ccusage daily --json  # 输出 JSON 格式
ccusage daily --breakdown  # 各模型成本明细

# 项目分析
ccusage daily --instances  # 按项目/实例分组
ccusage daily --project myproject  # 筛选特定项目
ccusage daily --instances --project myproject --json  # 组合用法
```



## 如何省钱

1. **减少无关文件**：为避免扫描不相关文件而造成 Token 消耗，具体的项目目录中启动 Claude Code，同时仅保留必要的项目文件。
2. **总结对话**：Claude Code 会将历史对话内容作为上下文，当对话长度达到上下文窗口的 95% 时，Claude Code 会自动地总结对话内容。可以通过执行`/compact`命令来手动地总结对话内容。
3. **精确指令**：模糊的请求会触发非必要的文件扫描，消耗更多的 Token。请在使用 Claude Code 时提出更明确、具体的问题或指令。
4. **分解任务**：在处理复杂任务时，可以将其分解为若干简单任务。
5. **重置上下文**：在开启一个全新的任务之前，使用`/clear`命令重置上下文，避免无关信息消耗 Token。



官方的输入token比输出token便宜的多，因此我们要大胆而准确的提供上下文，避免因误解而产生的无效输出，从根本上节约成本。



一些有明确规则，能写脚本处理的就不要让模型读了，能本地处理了就减少远程调用。



对于一些费token的操作，还是人做吧（网上说git之类的，CC需要git环境变量就是这样的，能帮你处理很多git相关操作）



## （全局 ）CLAUDE.md

这个也是控制CC精准回答~~（省钱）~~的好技巧



转载的一个全局CLAUDE.md,你可以自己研究一个你自己喜欢的生成代码风格,减少你手动修改生成代码的成本

```markdown
## 基本原则

- 无论我使用什么语言，请始终使用「简体中文」回答我的问题, 包括 Todo 和思考内容。
- 开始输出代码前最好联网搜索一下其最佳实践 (Best Practices)。
- 联网搜索的时候切忌采用 csdn.net、阿里云/腾讯云/华为云社区等内容农场 (Content Farm) 的信息，这些信息往往过时且质量低劣。

## Code Style 偏好

- 无论是 JS 还是 TS, 请尽可能偏向使用 ESM (import/export) 而不是 CJS (require)。
- 为了减少不必要的开支，请尽可能使用 `import { xxx } from 'xxx'` 而不是默认导入 (Node.js 项目无需遵守此规则)。
- 对于编写复杂的 GitHub Workflow 时，请尽可能使用 Python/Node.JS 等流行脚本语言，而不是 Bash。

## 依赖库偏好

- 编写 GitHub Workflow 时推荐使用流行、活跃的 Action 库，除非迫不得已，否则尽可能少造轮子。
- npm 依赖库偏好：我喜欢更流行、更新更热、活跃更新的 npm 库。例如, `yaml` 而不是 `js-yaml`。
- Golang 依赖库偏好：一般情况下最好使用标准库，其次才是由 Golang 官方维护的非标准库。
- 安装依赖可以使用 pnpm, 要用 bun add / bun install 时请追加 --no-cache 参数。

## 其他偏好

- 我讨厌在 JS/TS 中使用 class 写法，因为其代码可读性非常差。
- 条件允许的情况下，对于输出的 TypeScript 代码最好可以过一遍 linter 自动化检查并修复格式问题。
- 确保任务完成后，请尽可能完成项目中的 linter/formatter 自动化检查，随后再进行任务总结。
```





CLAUDE.md很重要，但CLAUDE.md也不要太长），毕竟CC会自动读取这个文件。

这个文件可以放一些注意事项，比如如服务器端口，如CC每次完成某一项任务，要带上证据文件,防止它测试失败还庆祝打√通过

然后对话时可以要求CC查询CLAUDE.md相关部分。



## “Magic Words” 控制思考预算

通过逆向 Claude Code 客户端得来的隐藏技巧，虽然看起来很 “Magic”, 但确实具有实用价值。

Claude Code 通过从输入 Prompt 中匹配特定的 英文关键词，可以动态调整它的 “思考预算” (Thinking Budget)，即在生成最终答案前内部思考和迭代所消耗的 Token 数量。



从使用的思考预算来看，think < think hard < think harder (ultrathink)。

- 基础思考 (think): 将消耗约 4K Tokens 预算用于思考，适用于大部分常规任务。

- 深度思考 (think hard): 将消耗约 10K Tokens 预算用于思考，当你需要它进行更复杂的逻辑推理或重构时使用。

- 极限思考 (ultrathink): 将消耗约 32K Toens 预算用于思考，用于攻克极其复杂、需要多步骤规划的难题。



>"帮我规划一个从 Vue 2 到 Vue 3 的多步骤迁移，每一个步骤都请 ultrathink。"
>"重构这个组件，并注意 think hard 性能问题。"
>"请修复这个 bug，可以适当 think 并检查一下可能存在的性能瓶颈。"





## 人为引导

我们除了设置整体目标,还需要引导CC



- 技术路线：随着项目进展我们甚至要做技术路线的调整。调整前可以让 CC 先做个微调研和 dirty tests。这也是能充分发挥 CC 顶级全栈通才的主要手段。
- 计划粒度：跨度太大的，AI做的并不是很好。要习惯在对话中根基计划定时拆解目标，压缩对话历史。
- 定期阶段性总结：不定期让 CC 自己写点反思和沉淀塞进 CLAUDE.md。



## 精心管理会话

CC工作时，我们可以使用esc打断它的工作，主要是以下几种情况需要停下



- 一些 CC 不擅长的任务，如系统缺包需要安装时：CC 的 bash 工具有限时紧张，大包的安装可能导致超时无法完成，因此我们手工代劳比较合适。
- 无头苍蝇状态时：CC 的好处是能自动纠错，但有时思路偏了就钻进牛角尖。比如因为代理服务器没设对，导致他连不上 google 或者没法 git clone 时，CC 可能会胡思乱想然后乱改程序和脚本，过一会儿程序就面目全非。此时再停，有一段污染的历史在记录里，浪费了 token 还对后面的质量会有影响。最好是事情失控前把 CC 断下来。



不过即使历史污染了，还有个补救是连按 esc 两次，此时可以选择直接跳回过去几轮的某一次（即回滚）。但是现在这个功能只能 undo 不能 redo，所以跳前三思。



esc 两次这个还可以用于临时做些小实验但不保留。

如果不小心退出了 claude 程序，可以用 --/continue 载入之前的会话历史。



当历史长度接近溢出时，会有提示



## 灵活使用不同模型

有一些CC不擅长的，可能GPT4.1就擅长了，这很难说是模型强弱的问题，只能说是各有所长，如果你觉得一个模型很不满意，就尝试换一下。



## 安全

CC是完全自动的agent，能改文件，上网，装系统，因此权限管理很头疼）。



文件编辑还好，放git就行（别让他跑出git管理的目录就行了）

bash命令还是要谨慎点。



我们可以自定义文件来限制那些指令不能执行，哪些可以执行

## 批量任务
CC本身也有个todo list，但是不长。  
如果我们需要给他一个很长的todolist，可以写一个md文件，每行写一个task，然后让他读取（或者使用bash命令）等

## 总结

还是要学习如何精准高效分步和AI对话，让AI先了解代码，再进行对话，问题从宽泛到具体，由浅入深。

尤其是处理CLAUDE.md。



感觉个人使用的话，不是重度使用就随便吧，如何是实习了，有money可以狠狠用了，就要仔细研究下怎么使用了。

传统的editor ai的劣势就是人可能会修改ai的代码，导致ai看到的文件状态和当前的不一致，导致ai混乱或者重读所有代码。。而cli就简简洁，没有代码提示什么的，人工无法接入，效率更高（前提是你prompt合理），还有模型质量要好



CC的长处：画图，理解关系等

- **快速实现算法**
- **搭建项目框架**
- **编写测试用例**
- **代码逻辑分析**
- **架构设计讨论**

短板：全局变量重命名？   复杂逻辑的重构。用idea的ide工具吧。。

LLM应该就是一个概率生成器，这类十分准确，复杂概率低的，就不应该让ai来。

或者你写一个脚本更合适。

还有一些冷门语言，训练资料少也会导致ai不擅长。

合理使用CC的plan mode。如果你经验丰富，了解项目架构，就可以大胆使用plan mode规划项目，给ai提供明确的计划和架构。

如果你还不是很熟悉，在探索，在选择，那就建议先让ai跑个demo来验证.

plan mode也能帮你整理，细化思路。

一般都是小步迭代的。如果你要放飞自我，建议先写好测试，可以用ai，即TDD方式。

CC的上下文也不是很大，建议先用plan mode规划好任务，拆分需求。文档化，逐步完成，可以新开一个session来完成小任务。也可以用多个agent来扩展上下文。

最好在合适的时间主动压缩上下文，不然ai跑一半自动压缩就很怪了。

# MCP

不看官方文档，你也可以直接让CC帮你安装一个MCP，或者把官方文档扔给他233。

- 获取某个网页，文档的最新内容



# 多CLAUDE交互
~~一个claude写代码，一个claude负责审查代码~~

# 自定义命令

重复的prompt最好要自定义命令，如

```
/test-and-fix     # 运行测试，如果有失败自动尝试修复
/review           # 对当前修改进行代码审查，给出改进建议  
/commit-suggest   # 分析改动，生成合适的 commit message 给用户参考
```



# GITHUB ACTION

你在仓库提issue，CC能自己写代码并提PR，push）
