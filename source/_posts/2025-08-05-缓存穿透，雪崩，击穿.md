---
title: 缓存穿透，雪崩，击穿
date: 2025-08-05 09:31:34
tags:
  - 缓存
  - redis
  - 后端
---

# 缓存穿透

## 定义

客户端请求的数据在缓存和数据库中均不存在，这样缓存就会失效，客户端请求就会穿透缓存直达数据库。



如果有大量恶意，异常请求进行访问，数据库压力就会很大。

## 解决方案

- 缓存空对象：数据库查询不存在，在缓存层缓存一个短TTL的空值，特殊值。
  - 实现简单，维护方便
  - 额外的内存消耗（需要内存淘汰策略），短期的缓存与数据库不一致。
  - 适用场景：数据不存在可能性低，业务容忍短暂不一致（如商品详情页）。
  
- 布隆过滤器: 在缓存层加上过滤层，过滤无效的请求
  - 内存利用率高，没有多余的key
  - 实现复杂，存在误判风险（假阳性: 判断不存在的数据一定不存在，判断存在的数据不一定存在）
- 多级校验
  - 接口层校验：增强id复杂度，避免被猜测id规律。对请求参数进行合法性校验（id格式，范围），拦截非法请求
  - 规则过滤：用业务规则拦截明显无效请求（如未登录的用户不能请求订单数据）
  - 限流熔断：对频繁访问不存在key的IP或用户进行限流


# 缓存雪崩

## 定义

短时间大量缓存key同时过期或者缓存服务宕机，导致大量请求直达数据库。



流量洪峰冲击数据库，带来连锁问题。

## 解决方案

- Key过期时间优化
  - 基础随机化 TTL 增加一定范围随机值，适用性广
  - 核心业务（如支付）设置长TTL，非核心数据短TTL，适用于高并发系统。
  - 热Key续期：异步线程在过期前主动续期（提前一段时间检测访问频率，高频Key自动延长TTL），适用于热点数据。

- 多级缓存（本地缓存+redis集群)

  - 本地缓存：应对R-edis崩溃（如Guava/Caffeine，短TTL），处理突发流量。

  - 分布式缓存：数据一致性保障（Redis集群，TTL分层设置）。
  - 持久化数据库：数据兜底（MySQL分库分表+读写分离）

  - 数据同步：通过Redis Pub/Sub或监听Binlog（Canal）更新本地缓存。

  - 多级缓存都不命中，那么就可能采取降级策略：熔断/默认值等。

- 服务降级与限流
  - 熔断：当数据库qps达到阈值自动熔断，返回兜底数据
  - 限流：
    - 网关层限制单个IP/user的请求量
    - 业务层现在DB查询线程池大小

# 缓存击穿

## 定义

## 解决方案
