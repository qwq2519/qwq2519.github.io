---
title: 缓存穿透，雪崩，击穿
date: 2025-08-05 09:31:34
tags:
  - 缓存
  - redis
  - 后端
---

# 缓存穿透

## 定义

客户端请求的数据在缓存和数据库中均不存在，这样缓存就会失效，客户端请求就会穿透缓存直达数据库。



如果有大量恶意，异常请求进行访问，数据库压力就会很大。

## 解决方案

- 缓存空对象：数据库查询不存在，在缓存层缓存一个短TTL的空值，特殊值。
  - 实现简单，维护方便
  - 额外的内存消耗（需要内存淘汰策略），短期的缓存与数据库不一致。
  - 适用场景：数据不存在可能性低，业务容忍短暂不一致（如商品详情页）。
  
- 布隆过滤器: 在缓存层加上过滤层，过滤无效的请求
  - 内存利用率高，没有多余的key
  - 实现复杂，存在误判风险（假阳性: 判断不存在的数据一定不存在，判断存在的数据不一定存在）
- 多级校验
  - 接口层校验：增强id复杂度，避免被猜测id规律。对请求参数进行合法性校验（id格式，范围），拦截非法请求
  - 规则过滤：用业务规则拦截明显无效请求（如未登录的用户不能请求订单数据）
  - 限流熔断：对频繁访问不存在key的IP或用户进行限流


# 缓存雪崩

## 定义

短时间大量缓存key同时过期或者缓存服务宕机，导致大量请求直达数据库。



流量洪峰冲击数据库，带来连锁问题。

## 解决方案

- Key过期时间优化
  - 基础随机化 TTL 增加一定范围随机值，适用性广
  - 核心业务（如支付）设置长TTL，非核心数据短TTL，适用于高并发系统。
  - 热Key续期：异步线程在过期前主动续期（提前一段时间检测访问频率，高频Key自动延长TTL），适用于热点数据。

- 多级缓存（本地缓存+redis集群)

  - 本地缓存：应对R-edis崩溃（如Guava/Caffeine，短TTL），处理突发流量。

  - 分布式缓存：数据一致性保障（Redis集群，TTL分层设置）。
  - 持久化数据库：数据兜底（MySQL分库分表+读写分离）

  - 数据同步：通过Redis Pub/Sub或监听Binlog（Canal）更新本地缓存。

  - 多级缓存都不命中，那么就可能采取降级策略：熔断/默认值等。

- 服务降级与限流
  - 熔断：当数据库qps达到阈值自动熔断，返回兜底数据
  - 限流：
    - 网关层限制单个IP/user的请求量
    - 业务层现在DB查询线程池大小

# 缓存击穿

## 定义

又叫热Key问题，指的是一个，特定的高频访问且缓存重构业务复杂的key突然失效了，瞬间给数据库带来巨大压力。

## 解决方案

### 互斥锁
原理： 缓存失效时，只允许一个线程重建缓存，其他线程等待。

实现： 
- 使用Redis SETNX或分布式锁来当互斥锁。
- 为锁操作设置超时时间（如 100ms），避免死锁导致系统雪崩

优缺点：
  - 没有额外内存消耗，一致性好，实现简单
  - 线程需要等待，性能不好，有死锁风险

### 逻辑过期
原理： 缓存物理上不过期，但存储 数据 + 逻辑过期时间。  业务检查时间戳，判断是否过期，过期则异步重建。

实现： 
- 独立线程刷新： 后台线程定期刷新热Key，避免业务线程阻塞（定时任务or消息队列触发）
- 双缓存策略： 设置主备缓存，主缓存过期短暂返回备缓存。

优缺点：
- 线程无需等待，性能好
- 不保证一致性，有额外内存消耗，实现复杂




### **选型建议**

| **方案** |          适用场景          |           注意事项            |
| :------: | :------------------------: | :---------------------------: |
|  互斥锁  | 数据一致性要求高、低频重建 | 避免锁冲突带来的延迟,性能下降 |
| 逻辑过期 |   高并发、允许短暂不一致   |    需监控内存占用和脏读风     |

### **总结**

缓存击穿的核心在于**平衡高并发与数据一致性**：

对于预测的热点key流量高峰，要进行缓存预热



- 对强一致性场景（如支付）用**互斥锁+超时降级**；
- 对高并发弱一致性场景（如资讯）用**逻辑过期+后台刷新**；
- 对极高并发场景（如春晚红包）用**本地缓存+热 Key 预热**。
