---
title: 零散八股，面试题记录
date: 2025-09-10 17:00:05
tags:
---



# 数据库

1. redis为什么先写命令然后再写到AOF文件中，而不是采用WAL机制
WAL（Write-Ahead Logging，预写日志）:先写日志到磁盘并且刷盘成功，事务才能执行内存中的数据页更新，数据页的磁盘写入可以延后批量处理。

- 日志写入是顺序IO，而数据页写入是随机IO。将数据页随机写优化为 日志顺序写和后续数据页批量刷盘，提升IO性能。
- 事务更改了内存数据页，但是未成功刷盘，会导致修改丢失，违反ACID的持久性。而WAL可以在崩溃后重做已提交的事务，回滚未提交的事务，保证原子性持久性。

但是Redis的核心定位是高性能内存数据库
- Redis的写命令是内存操作，写AOF文件是磁盘操作。先写AOF再执行命令会导致内存操作等待磁盘IO。
- AOF文件的作用是记录执行成功的命令用来回复，是事后日志，而非WAL(记录待执行的操作)。Redis应该有其他的重试机制，如果失败了也不需写入AOF

当然，AOF可能存在风险（命令执行成功后但是AOF写入前，Redis宕机），这就就是AOF刷盘策略的问题了，要在性能和数据安全之间平衡。AOF的缓冲区就是这样的。

并且Redis还要检查命令格式是否正确。



2. mysql默认隔离级别是可重复读，但是有些问题。

它解决了大部分幻读问题，但在SQL标准中这是串行化级别才该解决的问题。。

并且在读写两个操作上区别对待。比如那个经典的不能避免的幻读（查不到，但是能更改，更改后就能查到了）

本质是select语句是快照读（读取的是开始事务时的快照），而update语句是当前读（不走快照），这种区别对待就导致了这样的问题，不知道会带来什么问题，反用户思维）。

并且在高并发情况下，间隙锁可能会退化带来性能问题。



MySQL主从同步使用binlog，早期binlog只有statement格式，当出现事务乱序时，备库通过binlog回放会与主库内容不一致。因此MySQL采用RR隔离级别，在更新数据时会增加临键锁避免。

但是有些大厂不使用默认的RR，而是RC。



一致性读（快照读），读取当前行记录的历史版本，即通过read view追溯特定版本的记录快照。只有RC和RR才使用一致性读。

- RC，每次读取都会生成一个快照。RR是在事务第一次执行select语句生成，只有本事务对数据进行更新时才会更新快照。此外，RC还支持半一致性读：update语句如何where匹配到的记录已经枷锁，那么innodb会返回记录最新提交的版本，由mysql上层判断是否需要加锁。
- RC只会使用记录锁。RR为了解决幻读，还增加了间隙锁和临键锁。
- RC只支持row格式的binlog。（你选mixed格式+RC，也会自动选择row）。RR三种都支持（statement row mixed）

因此，RC加锁更简单，支持半一致性读，减少update语句的加锁冲突，对于不满足更新条件的记录可以提前释放锁，大大提高并发度。锁的粒度降低了，也降低了死锁概率。幻读发生概率并不大，还可以采取其他方式解决
