---
title: Radix Tree
date: 2025-09-20 21:48:01
tags:
  - 数据结构
---

# 是什么

Radix tree（Radix trie，compact prefix tree），一种前缀压缩优化的trie（前缀树），解决了普通trie空间利用率低的问题。

如果一个节点只有一个子节点，那么该子节点会和父节点合并，即合并了前缀相同的节点,实现前缀压缩，而普通trie限制了一个节点只能表示一个字符，而radix一个节点可以表示多个字符。

# 有什么用

还是前缀树，核心能力是前缀匹配查询，因此广泛用于字符串处理，IP路由匹配，缓存系统。特别是长字符串的存储查找，前缀重复多的情景。

要是特别长的字符串，甚至可以通过数学计算计算出特征值，再用radix管理，进一步压缩存储。



Linux中也实现了radix树。对于长整数数据的管理和映射，用hash表可能存在高频冲突。而radix能高效完成插入和存储，查询，可以管理指针。

有01trie，也就有01radix。一般用2bit或者4bit为一个radix节点。malloc()次数过多领导时候可能采用池化技术，提前分配。还可以实现惰性删除，只删除叶子结点，非叶子节点就留着，反正复用的概率很大。特别是01化后，感觉结构很像B+树了，每个节点都是m叉的，且树结构扁平规整。

redis也实现rax树（radix tree），在内存中是顺序结构。有两种保存数据的格式压缩/非压缩，就是trie和radix树



此外还延伸出了ART（adaptive Radix tree），会提供多种类型的节点，分别根据当前节点有效指针数量选择合适的节点类型。

# 实现

维护前缀压缩这一性质的过程中，不可避免有节点拆分和合并，导致实现会比较复杂。对于



- 查：和普通Trie类似。

- 插入：寻找和新字符串存在LCP（最长公共前缀）的字符串，如果LCP长度=子节点片段长度，则可以在子节点处插入孙节点。如果LCP长度<子节点片段长度，则需要将子节点一分为二新节点。如果没有找到公共前缀子节点，则只能直接插入字符串作为新的子节点。

- 删：删除目标节点，检查其父节点(且本身不是终止节点)是否需要合并。

  





## 比较

- radix的各种操作的复杂度都存入的字符串长度有关。层高也比较低。查询更快，但是缓存利用率不一定（每个节点表示的字符串大小不一定，不如trie的使用数组或者哈希表实现的子节点管理）。

- 平衡树一般都是logn。看起来平衡树更快？但是平衡树的key也需要进行字符串比较，也要耗时。。但是平衡树通用性更高，适用于任何可以比较的类型
- 普通trie，一样。但是比较次数比radix更多
- 哈希表，一般认为都是O1的，很快，但是哈希碰撞和哈希扩容就不一定了，比较哈希表也是一个数组，扩容麻烦。并且也不支持查询前驱和后继，范围查询页不擅长
- 特别是ART，路径压缩和自适应节点分配，大大减少空间浪费，相比B+索引，节点更小缓存更好，在纯内存场景中优势很明显。

