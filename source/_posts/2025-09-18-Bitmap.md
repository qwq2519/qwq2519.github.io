---
title: Bitmap
date: 2025-09-18 23:15:09
tags:
  - 数据结构
---


#  BitMap

就是位数组,可以用来去重，标记。

位数组的大小很大，但是使用量不多，数据分步不均匀，很浪费空间。谷歌的EWAHCompressedBitmap就进行了压缩优化

BitMap算法的开源实现由JDK的BitSet和谷歌的EWAHCompressedBitmap。



还有比如一个用户表里，有很多用户属性字段，要快速根据某个字段来进行统计的话，用bitmap就可以了。交集并集什么的，去重，比写sql又快又简单，省空间。这个场景下，要进行非运算就不能直接进行非运算了。要用特定字段对应的bitmap和表示所有用户的bitmap进行异或。



- 海量数字，问某个数字是否存在
- 海量数字，问是否有重复的。
- 海量数字，要进行去重，排序
- 海量数字，问你有哪些是重复的

  - 用2-BitMap，一个整数用两位表示，可以有四种状态了。

  - 用两个bitmap。

  - 分治+Hash。对海量数字的值域进行分桶，分块读取海量数据，生成分桶统计文件。最后在内存维护一个哈希表，逐个或者逐群地读取分桶统计文件。

  - 外部排序法（如果还需要排序的话，可以用多路归并）。对内存要求最低？，但是磁盘IO就很大了。

  - 总结：位图适合整数范围可控的，速度快，内存占用小如32位整数。64位就不行了。哈希分桶通用性强，内存占用可控，但是需要多次IO，比较慢


当然，对于大量数据，超大量范围，我们可以对原始数据进行离散化处理（算法竞赛的），排序后一一映射（浮点数什么的也方便了），缩小值域，这样可以用一个比较小的bitmap进行处理了。






为什么不用哈希表？

- bitmap运算更快

- 哈希表要存key，存是否存在，处理哈希冲突,资源利用率没那么极限
- 哈希表的优点是通用性强，特别是要存储字符串的时候，如果有哈希冲突，bitmap就没什么优势了。因此bitmap适用于整数数据，不然就要用布隆过滤器了。
- bitmap的大小和数据最大值相关，而哈希表大小和数据量相关。因此bitmap适用于量大的数据,并且只需要简单记录状态。

两个是互补的）



# EWAHCompressedBitmap

**Enhanced Word-Aligned Hybrid Compressed Bitmap** 专门用于特别稀疏位图的压缩技术，省空间。传统的压缩算法（ZIP）需要解压后才能操作，这个就不需要了。

底层逻辑是按字对齐（32位or64位，看CPU字长，跟CPU有关了，对齐），分块存储。

块有不同类型的，来实现压缩。有多种实现。

当然，压缩了省空间了，时间复杂度就起来了，普通bitmap随机访问肯定是o1的，压缩后访问应该就是logn级别的，但是还是很快。

核心优势是位运算无需全解压，可以分块进行运算，解压部分块，编码简单，跨平台，快。



缺点就是中等稀疏场景（0,1频繁交错的），压缩效果低。也不适合频繁修改（都压缩了，你还想修改。。压缩文件你还能快速修改吗）。实现简单，但是适用性和性能一般也不如下面的另一个Roaring Bitmap



谷歌的，针对于大bitset，但是数据量少的情况下，进行压缩，提升空间利用率。

用long（64位）整数在作为bitmap底层结构，bitmap集合是由一个个long整数构成的long数组，long数就是子集。一个long可以成为一个word。初始值值有一个word0，可以存bitmap一些元信息

可以很简单的想到可以实现动态数组了）。



但是如果突然要插入一个很大的数114514，EWAH可不会傻傻的扩容出一堆long。而是可以用两个long，一个作为特殊值，一个作为真正的存114514的long。

word可以分为两种

- Literal Word : LW 直接存数据
- Running  Length Word ： RLW 存储跨度信息。word0是这种类型的。
  - RLW的低32位表示当前word横跨多少空word
  - 高32位表示当前RLW有连续几个LW

这样插入新值的时候,用RLW作为路标快速跳跃，传统的bitmap可能就直接起始地址+位置来定位，像是数组，而EWAH就没那么方便了。如果插入的新值刚好在RLW横跨的区间内，就要进行RLW分裂，可能会涉及很多word移动，类似redis的ziplist的连锁，级联更新吧，很消耗性能，因此googgle官方建议从小到大插入数据

用链表可以解决级联更新吧，但是时空。。。。指针？ 破坏CPU字长对齐？离散存储，实现复杂。还有EWAH本身就不适合频繁修改的，适合读多写少的。需要频繁修改的看下面那个。

# Roaring Bitmap

和EWAH又是另一种技术了，核心逻辑在于块划分逻辑和压缩策略。好像可以简称为RBM，16年才在论文出现的



该算法，块长是可变的，按照块内元素密度选择容器（数组/位图），适合中等稀疏场景，压缩率更高。位运算更快，但是实现比较复杂。

（中等稀疏）适用场景更广，性能也更好点。



- 将32位无符号数据类型，根据高16位划分到65536个桶中（进行索引分片），论文称为container。每个container存放数值的低16位。
- 存储和查询数值k时，根据k的高16位和低16位来计算。

container有几种类型

- arraycontainer：每个元素都是short两字节，里面的元素都是有序的。元素数量超过4096后会升级为bitmapcontainer。小于4096个时比较省空间，适合存储稀疏数据
- bitmapcontainer：固定为8k大小，就是位图，位数为2^16个，使用long数组实现。适合存储稠密的数据
- runcontainer：run是行程长度压缩算法，对于连续的数据进行压缩。
  - 对于连续出现的数字，只记录初始的数字和后续的数量。如 11->11,0      11 12 13 14 15 -> 11,4等。
  - 这种容器不常用。压缩效率和数据的连续性紧凑型关系密切，有可能会导致反压缩。。
  - 假设只有一个数字或者只有一串连续数字，那么只需要2short，4字节
  - 假设全部都是01交错，那么需要65536个short，128kb

bitmap容器可以直接O1寻址，另外两个要二分查找。一般容器只会在前两个之间进行转换。第三个容器只有用户调用优化方法时才会主动被转换出来。



和原生的bitmap相比，内存占用小，交并集运算更快

- 计算优化：本质上是将大块bitmap拆分为小块，计算时只需要选择存在的块。用实现逻辑的复杂度得到了更优的时空
- 逻辑优化：维护了排序的以及索引和有序的arraycontainer，进行交集运算时，通过索引来获得需要合并的容器等。



论文中的rbm是32位的，但也对64位进行扩展

- Roaring64NavigableMap：使用红黑树，k是32位整数，v是32位RBM
- Roaring64Bitmap：依赖ART数据结构保存键值对，k是48位，v是16位的RBM



[RoaringBitmap/RoaringBitmap: A better compressed bitset in Java: used by Apache Spark, Netflix Atlas, Apache Pinot, Tablesaw, and many others](https://github.com/RoaringBitmap/RoaringBitmap)

