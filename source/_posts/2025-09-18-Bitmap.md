---
title: Bitmap
date: 2025-09-18 23:15:09
tags:
  - 数据结构
---


#  BitMap

就是位数组,可以用来去重，标记。

位数组的大小很大，但是使用量不多，数据分步不均匀，很浪费空间。谷歌的EWAHCompressedBitmap就进行了压缩优化

BitMap算法的开源实现由JDK的BitSet和谷歌的EWAHCompressedBitmap。



还有比如一个用户表里，有很多用户属性字段，要快速根据某个字段来进行统计的话，用bitmap就可以了。交集并集什么的，去重，比写sql又快又简单，省空间。这个场景下，要进行非运算就不能直接进行非运算了。要用特定字段对应的bitmap和表示所有用户的bitmap进行异或。



- 海量数字，问某个数字是否存在

- 海量数字，问是否有重复的。

- 海量数字，要进行去重，排序

- 海量数字，问你有哪些是重复的

  - 用2-BitMap，一个整数用两位表示，可以有四种状态了。

  - 用两个bitmap。

  - 分治+Hash。对海量数字的值域进行分桶，分块读取海量数据，生成分桶统计文件。最后在内存维护一个哈希表，逐个或者逐群地读取分桶统计文件。

  - 外部排序法（如果还需要排序的话，可以用多路归并）。对内存要求最低？，但是磁盘IO就很大了。

  - 总结：位图适合整数范围可控的，速度快，内存占用小如32位整数。64位就不行了。哈希分桶通用性强，内存占用可控，但是需要多次IO，比较慢

    




为什么不用哈希表？

- bitmap运算更快

- 哈希表要存key，存是否存在，处理哈希冲突,资源利用率没那么极限
- 哈希表的优点是通用性强，特别是要存储字符串的时候，如果有哈希冲突，bitmap就没什么优势了。因此bitmap适用于整数数据，不然就要用布隆过滤器了。
- bitmap的大小和数据最大值相关，而哈希表大小和数据量相关。因此bitmap适用于量大的数据,并且只需要简单记录状态。

两个是互补的）



## EWAHCompressedBitmap

谷歌的，针对于大bitset，但是数据量少的情况下，进行压缩，提升空间利用率。

用long（64位）整数在作为bitmap底层结构，bitmap集合是由一个个long整数构成的long数组，long数就是子集。一个long可以成为一个word。初始值值有一个word0，可以存bitmap一些元信息

可以很简单的想到可以实现动态数组了）。





但是如果突然要插入一个很大的数114514，EWAH可不会傻傻的扩容出一堆long。而是可以用两个long，一个作为特殊值，一个作为真正的存114514的long。

word可以分为两种

- Literal Word : LW 直接存数据
- Running  Length Word ： RLW 存储跨度信息。word0是这种类型的。
  - RLW的低32位表示当前word横跨多少空word
  - 高32位表示当前RLW有连续几个LW

这样插入新值的时候,用RLW作为路标快速跳跃，传统的bitmap可能就直接起始地址+位置来定位，像是数组，而EWAH就没那么方便了。如果插入的新值刚好在RLW横跨的区间内，就要进行RLW分裂，可能会涉及很多word移动，类似redis的ziplist的连锁，级联更新吧，很消耗性能，因此googgle官方建议从小到大插入数据
