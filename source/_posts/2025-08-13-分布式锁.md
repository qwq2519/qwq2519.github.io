---
title: 分布式锁
date: 2025-08-13 14:27:17
tags:
  - redis
---

# 分布式锁

锁具有互斥性，一个线程拿不到锁，就不能继续执行，保证了数据一致性，并发安全等



普通单实例项目，用普通锁就行了。但是分布式项目就要用分布式锁了，实现多实例的锁的共享。



分布式锁需要的特性

- 互斥性：
- 安全性：避免死锁，锁一定要能释放
- 高性能：加锁解锁开销小
- 可重入性
- 容错性：部分节点故障不影响锁整体功能



redis执行命令是单线程的, 对于单个redis命令是能保证原子性的。

还有Redission，是redis的java客户端框架，提供了很多强大的功能。

对于一些简单的重复的上锁代码，可以用aop抽离或者定义方法。



- 如何实现互斥，使用redis setnx
- 加锁后要解锁，需要判断 这把锁是不是本线程的。        
  - 1. 判断 2. 释放 是两步，需要保证原子性  ----》 Lua脚本



- 线程拿到锁了，但是线程挂了，那么锁就永远不会释放？

  -  锁要有过期时间

    

- 线程没挂，但是执行业务耗时很久，导致锁到期释放了。 

  - 看门狗机制,用一个看门狗线程定期给锁延续过期时间，保证业务线程执行期间拿到的锁不会过期。
  - 如果业务线程挂了，看门狗线程就不要继续续期了，所以看门狗线程是该业务线程的守护线程。        



- 开发时可能会涉及递归，涉及多个方法嵌套调用。这时同一个业务线程可能多次获取同一把锁
  - 使用可重入锁，需要一个锁计数器
    - redis的hash，  { 锁名：{线程id ：计数器} }。  这是Redission方案。  集群模式下线程id要保证唯一性
    - redis的string + ConcurrentHashMap，map当计数器



- 线程抢锁失败，是不是直接不抢了？ 一般是会继续抢的，这就阻塞了线程
  - 让锁去自旋，没抢到就自旋
  - redission采用redis的发布订阅模式: 没抢到锁的订阅+阻塞，抢到锁的线程执行完就发布一条消息，让剩下的线程去抢锁。
  - 一般都会有一个超时时间，避免无限阻塞



- 如果redis是主从结构，如果setnx在主节点写入锁，同步之前主节点挂了，这时会重新选举主节点，就导致了分布式锁丢失。  服务器以为加锁成功了，但是其实没有，其他线程还能抢到锁
  - redission的联锁，每次给多主或者多主多从节点上锁才算加锁成功。这样挂掉一个节点，其他线程要加锁也会失败。
    - 要是一个主节点挂了或者网络延迟大，会导致加锁失败，这样无法使用分布式锁了。失败了还要回滚其他节点的已经上锁的数据
  - 红锁：给多主节点上锁，半数主节点上锁成功即可。有些节点加锁超时了就不管了。
    - 红锁对时间要求严格，但是各个节点时钟可能不一致，还有java的gc，gc会暂停线程导致看门狗无法续期。
    - 需要自己实现，运维复杂。
  - 所以流行的方案就是自己实现简单的分布式锁或者用redission的

