---
title: redis源码阅读-数据存储与管理-动态字符串库
date: 2025-09-09 13:24:13
tags:
  - redis
---

动态字符串库SDS是redis自己实现的高效，二进制安全（自动内存管理）。并且比C字符串多了O(1)长度查询，减少内存分配，能存储二进制数据。



其实就是一个对C字符串的现代化封装,也尝试兼容C字符串，如添加空字符到末尾，使得能使用一部分C字符串函数。

Redis中也用C字符串，一般用来当字符串字面量来表示一些不会修改的字符串，如日志。

# 架构概览

SDS的元数据存储在字符串数据前面。

可以直接当做C字符串使用，并且维护了长度，分配信息等。

头部信息根据字符串实际长度设计了五种头部类型，最小化内存开销

![image-20250909143725613](./../images/image-20250909143725613.png)

![image-20250909143912503](./../images/image-20250909143912503.png)

```c
/* Note: sdshdr5 is never used, we just access the flags byte directly.
 * However is here to document the layout of type 5 SDS strings. */
//__attribute__ ((__packed__)),取消结构体的内存对齐优化，使结构体成员按实际字节紧密排列，节省内存空间。

struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; /* used */
    uint8_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len; /* used */
    uint16_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len; /* used */
    uint32_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len; /* used */
    uint64_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};

char sdsReqType(size_t string_size) {
    if (string_size < 1 << 5) return SDS_TYPE_5;
    if (string_size <= (1 << 8) - sizeof(struct sdshdr8) - 1) return SDS_TYPE_8;
    if (string_size <= (1 << 16) - sizeof(struct sdshdr16) - 1) return SDS_TYPE_16;
#if (LONG_MAX == LLONG_MAX)
    if (string_size <= (1ll << 32) - sizeof(struct sdshdr32) - 1) return SDS_TYPE_32;
    return SDS_TYPE_64;
#else
    return SDS_TYPE_32;
#endif
}
```



# 核心功能

![image-20250909144346340](./../images/image-20250909144346340.png)

封装一些常见api

# 内存管理策略

C字符串的长度是固定的，固定为实际存储字符串的长度+1。这样要扩展或者缩短C字符串就需要重分配内存，如果不

- 拼接不扩展空间，则会导致缓冲区溢出
- 缩短字符串不释放，会导致内存泄露

Redis作为数据库，数据频繁修改，性能要求高，这是不可以接受的。



![image-20250909144551027](./../images/image-20250909144551027.png)

采用多种内存扩展策略

- 贪心：额外分配，减少未来的内存分配
- 非贪心分配：只扩展实际需要的长度
- 类型更新:会自动更新sds的类型
- 内存压缩:sdsRemoveFreeSpace（）方法会真正回收sds的空闲空间，进行内存重分配。这其实是惰性释放空闲空间，可以在特定时刻回收内存。如客户端空闲，空闲空间超过一个阈值等



```C

#define SDS_MAX_PREALLOC (1024*1024) //1MB


sds _sdsMakeRoomFor(sds s, size_t addlen, int greedy) {
    void *sh, *newsh;
    size_t avail = sdsavail(s);
    size_t len, newlen, reqlen;
    char type, oldtype = sdsType(s);
    int hdrlen;
    size_t bufsize, usable;
    int use_realloc;

    /* Return ASAP if there is enough space left. */
    if (avail >= addlen) return s;

    len = sdslen(s);
    sh = (char*)s-sdsHdrSize(oldtype);
    reqlen = newlen = (len+addlen);
    assert(newlen > len);   /* Catch size_t overflow */
    if (greedy == 1) {
        if (newlen < SDS_MAX_PREALLOC)
            newlen *= 2;
        else
            newlen += SDS_MAX_PREALLOC;
    }

    type = sdsReqType(newlen);

    /* Don't use type 5: the user is appending to the string and type 5 is
     * not able to remember empty space, so sdsMakeRoomFor() must be called
     * at every appending operation. */
    if (type == SDS_TYPE_5) type = SDS_TYPE_8;

    hdrlen = sdsHdrSize(type);
    assert(hdrlen + newlen + 1 > reqlen);  /* Catch size_t overflow */
    use_realloc = (oldtype == type);
    if (use_realloc) {
        newsh = s_realloc_usable(sh, hdrlen + newlen + 1, &bufsize);
        if (newsh == NULL) return NULL;
        s = (char*)newsh + hdrlen;
        if (adjustTypeIfNeeded(&type, &hdrlen, bufsize)) {
            memmove((char *)newsh + hdrlen, s, len + 1);
            s = (char *)newsh + hdrlen;
            s[-1] = type;
            sdssetlen(s, len);
        }
    } else {
        /* Since the header size changes, need to move the string forward,
         * and can't use realloc */
        newsh = s_malloc_usable(hdrlen + newlen + 1, &bufsize);
        if (newsh == NULL) return NULL;
        adjustTypeIfNeeded(&type, &hdrlen, bufsize);
        memcpy((char*)newsh+hdrlen, s, len+1);
        s_free(sh);
        s = (char*)newsh+hdrlen;
        s[-1] = type;
        sdssetlen(s, len);
    }
    usable = bufsize - hdrlen - 1;
    assert(type == SDS_TYPE_5 || usable <= sdsTypeMaxSize(type));
    sdssetalloc(s, usable);
    return s;
}

/* Enlarge the free space at the end of the sds string more than needed,
 * This is useful to avoid repeated re-allocations when repeatedly appending to the sds. */
sds sdsMakeRoomFor(sds s, size_t addlen) {
    return _sdsMakeRoomFor(s, addlen, 1);
}

/* Unlike sdsMakeRoomFor(), this one just grows to the necessary size. */
sds sdsMakeRoomForNonGreedy(sds s, size_t addlen) {
    return _sdsMakeRoomFor(s, addlen, 0);
}
```



# 在Redis中的应用

作为Redis自定义的字符串类，在Redis中的数据结构，协议处理，内部操作等有广泛应用。

![image-20250909145017935](./../images/image-20250909145017935.png)

- Redis Object：String Object使用SDS来存值
- 协议处理：RESP协议解析和生成的指令和响应结果使用SDS
- Key 存储：dict的keys使用sds存储
- 副本：指令传播使用SDS来缓冲与传输
- 持久化：AOF指令和RDB字符串值使用SDS。
- 缓冲区：AOF缓冲区和客户端状态的输入缓冲区



# 变体和兼容性

Redis有两种SDS实现版本：主版本和hiredis版本。有些许差别

![image-20250909145419793](./../images/image-20250909145419793.png)

# 性能特点

相对于C字符串

- O(1)常数获取，因为SDS头有个len字段
- 减少内存分配：动态贪心分配内存
- 缓存友好布局：连续内存布局提升了缓存的表现
- 二进制安全：len字段能处理二进制数据（音频图像等）。C字符串的字符必须符合某种编码（如ASCLL），且不能包含空字符，这就只能存文本数据。SDS的所有API都以二进制方式来处理buf数组的数据，buf应该是字节数组。
- 缓冲区不溢出：C字符串容易缓冲区溢出，而SDS会进行检查。
- 内存高效：头类型动态选择，最小化开销

还有一些自带库，比C库性能更高。
