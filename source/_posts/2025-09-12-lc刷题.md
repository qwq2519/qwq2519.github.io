---
title: lc刷题
date: 2025-09-12 22:22:04
tags:
  - 刷题
---


# 链表

## 234回文链表 hot100

找中间节点，然后翻转后半链表，然后首尾同时向中间跳咯

```java
class Solution {

    public ListNode reverseList(ListNode head){
        ListNode prev=null;
        ListNode p =head;
        while(p!=null){
            ListNode next =p.next;

            p.next=prev;
            prev=p;
            p=next;
        }

        return prev;
        
    }

    //快慢指针 奇数找正中间，偶数找正中间偏右的
    //while里面的条件是怎么回事？  笨蛋，这两个不判断下面不就可能会NPE吗
    public ListNode findMid(ListNode head){
        ListNode slow=head;
        ListNode fast=head;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
        }
        return slow;
    }
    //翻转后，tail的尽头的null，但是head的尽头是连着tail的尾节点
    public boolean isPalindrome(ListNode head) {
        ListNode tail = reverseList(findMid(head));
        while(tail!=null){
            if(tail.val!=head.val){
                return false;
            }
            tail=tail.next;
            head=head.next;
        }
        return true;
    }
}
```

## 141 环形链表 hot100

快慢指针

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        
        if(head==null){
            return false;
        }

        ListNode slow=head;
        ListNode fast=head;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(fast==slow){
                return true;
            }
        }

        return false;
    }
}
```

## 142 环形链表二 hot100

快慢指针加一个简单的数学证明（
```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        
        if(head==null){
            return null;
        }

        ListNode slow=head;
        ListNode fast=head;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            //找到了环了
            if(fast==slow){

                while(head!=slow){
                    head=head.next;
                    slow=slow.next;
                }
                return head;
            }
        }

        return null;
    }
}
```



## 21 合并两个有序链表 hot100

就合并。while如果改成逻辑与的话可以抽离部分逻辑出来，比较好看，变成三个while

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy=new ListNode(-1,null);
        ListNode p=dummy;
        ListNode pA=list1;
        ListNode pB=list2;
        while(pA!=null||pB!=null){
            if(pA==null){
                p.next=new ListNode(pB.val,null);
                p=p.next;
                pB=pB.next;
            }else if(pB==null){
                p.next=new ListNode(pA.val,null);
                p=p.next;
                pA=pA.next;
            }else{
                if(pA.val>=pB.val){
                    p.next=new ListNode(pB.val,null);
                    p=p.next;
                    pB=pB.next;
                }else{
                    p.next=new ListNode(pA.val,null);
                    p=p.next;
                    pA=pA.next;
                }
            }
        }

        return dummy.next;
    }
}
```

## 24 两两交换链表中的节点 hot100

两两拆出来交换就行了。

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy=new ListNode(-1,head);
        ListNode p=dummy;
        while(p.next!=null&&p.next.next!=null){
            ListNode first=p.next;
            ListNode second=p.next.next;
            ListNode three=p.next.next.next;

            p.next=second;
            second.next=first;
            first.next=three;

            p=first;
        }        
        return dummy.next;
    }
}
```

## 2 两数相加 hot100

类似于合并链表

代码优化，总是保证p1是长的那条，减少代码量

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy=new ListNode(-1,null);
        ListNode p1=l1;
        ListNode p2=l2;
        ListNode p=dummy;
        int cnt=0;
        while(p1!=null||p2!=null){
            if(p1==null&&p2!=null){
                p1=p2;
                p2=null;
            }
            int a=p1.val;
            int b=p2==null ? 0:p2.val;

            int sum=a+b+cnt;
            p.next=new ListNode(sum%10,null);
            p=p.next;

            p1=p1.next;
            p2=p2==null? null:p2.next;

            cnt=sum/10;
        }
        if(cnt!=0){
            p.next=new ListNode(cnt,null);
            p=p.next;
        }

        return dummy.next;
    }
}
```

## 23 合并K个升序链表 hot100

用堆动态维护链表集合的头部就行了。

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> q=new PriorityQueue<ListNode>((a,b)-> a.val-b.val );

        for(int i=0;i<lists.length;++i){
            if(lists[i]!=null){
                q.add(lists[i]);
            }
        }

        ListNode dummy=new ListNode(-1,null);
        ListNode p=dummy;

        while(!q.isEmpty()){
            ListNode t=q.poll();

            p.next=new ListNode(t.val,null);
            p=p.next;

            if(t.next!=null){
                q.add(t.next);
            }
        }

        return dummy.next;
    }
}
```

## 19 删除链表倒数第n个节点 hot100

快慢指针

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {

        //可能会删除头节点，因此引入哨兵节点
        ListNode dummy=new ListNode(-1,head);

        ListNode fast=dummy;
        ListNode slow=dummy;

        for(int i=1;i<=n;++i){
            fast=fast.next;
        }
        while(fast.next!=null){
            fast=fast.next;
            slow=slow.next;
        }

        slow.next=slow.next.next;
        return dummy.next;
    }
}
```

## 25 K个一组翻转链表 hot100

```java
class Solution {

    public ListNode[] reverseList(ListNode head){
        ListNode tail=head;

        ListNode cur=head;
        ListNode prev=null;

        while(cur!=null){
            ListNode next=cur.next;

            cur.next=prev;

            prev=cur;
            cur=next;
        }

        return new ListNode[]{prev,tail};
    }

    public ListNode reverseKGroup(ListNode head, int k) {
        int cnt=0;
        
        ListNode dummy=new ListNode(0,head);
        ListNode p=dummy.next;
        ListNode prev=dummy;

        //类似双指针的思想吧，prev---p之间就是要反转的k个链表
        while(p!=null){
            ++cnt;
            if(cnt==k){
                
                //断开连接
                ListNode next=p.next;
                p.next=null;
                
                //新链表 t[1]<------t[0]    主链表是 prev---->p 这个方向
                ListNode[] t=reverseList(prev.next);

                prev.next=t[0];
                t[1].next=next;

                prev=t[1];
                p=next;
                cnt=0;
            }else{
                p=p.next;
            }
        }
        return dummy.next;
    }
}
```

## 138 随机链表的复制 hot100

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    //总体思路就是在原链表的里塞入新链表，然后最后拆分出来
    public Node copyRandomList(Node head) {
        
        if(head==null){
            return null;
        }

        //第一遍，直接在原链表基础上增生一遍
        for(Node p=head;p!=null;p=p.next.next){
            Node next=p.next;
            p.next=new Node(p.val);
            p.next.next=next;
        }

        //第二遍，确认新链表的random指针
        for(Node p=head;p!=null;p=p.next.next){
            Node q=p.next;
            if(p.random!=null){
                q.random=p.random.next;
            }
        }

        //第三遍，拆分出新链表,两两一对拆分
        Node ans=head.next;
        for(Node p=head,q=ans;p!=null;){
            Node nextp=p.next.next;
            Node nextq=q.next==null ? null:q.next.next;

            p.next=nextp;
            q.next=nextq;

            p=nextp;
            q=nextq;
        }
        return ans;
    }
}
```

## 146 LRU缓存 hot100

```java
class LRUCache {

    class Node{
        int key;
        int val;
        Node next;
        Node prev;
        Node(int K,int V){
            key=K;
            val=V;
            prev=null;
            next=null;
        }
    }

    int cap;
    Node dummy;//循环链表
    Map<Integer,Node> m=new HashMap<>();

    public LRUCache(int capacity) {
        cap=capacity;
        dummy=new Node(-1,-1);
        dummy.prev=dummy;
        dummy.next=dummy;
    }
    
    public int get(int key) {
        Node t=m.get(key);
        if(t==null){
            return -1;
        }
        remove(t);
        addToFront(t);
        return t.val;
    }
    
    public void put(int key, int value) {
        Node t=m.get(key);
        //不存在，则插入
        if(t==null){
            Node newNode=new Node(key,value);
            m.put(key,newNode);
            addToFront(newNode);
            if(m.size()==cap+1){
                m.remove(dummy.prev.key);
                remove(dummy.prev);            
            }
        }else{
            t.val=value;
            remove(t);
            addToFront(t);
        }
    }

    private void remove(Node p){
        p.next.prev=p.prev;
        p.prev.next=p.next;
        p.next=null;
        p.prev=null;
    }

    private void addToFront(Node f){
        Node head=dummy.next;

        head.prev=f;
        f.next=head;

        dummy.next=f;
        f.prev=dummy;
    }
}
```

## 148 排序链表 hot100

链表不能随机访问，只能局部访问，显然是归并了吧。

显然没必要那么多new的，但是为了方便就这样吧。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    //归并排序链表板
    public ListNode sortList(ListNode head) {
        if(head==null||head.next==null){
            return head;
        }
        ListNode mid=findMid(head);
        ListNode l=sortList(head);
        ListNode r=sortList(mid);
        return merge(l,r);
    }

    private ListNode findMid(ListNode head){
        ListNode fast=head;
        ListNode slow=head;
        ListNode prev=null;
        while(fast!=null&&fast.next!=null){
            prev=slow;
            fast=fast.next.next;
            slow=slow.next;
        }
        prev.next=null;
        return slow;
    }

    private ListNode merge(ListNode l1,ListNode l2){
        ListNode dummy=new ListNode(-1,null);
        ListNode p=dummy;
        ListNode n=l1;
        ListNode m=l2;
        while(n!=null&&m!=null){
            if(n.val<=m.val){
                p.next=new ListNode(n.val);
                n=n.next;
            }else{
                p.next=new ListNode(m.val);
                m=m.next;
            }
            p=p.next;
        }
        while(n!=null){
            p.next=new ListNode(n.val);
            n=n.next;
            p=p.next;
        }
        while(m!=null){
            p.next=new ListNode(m.val);
            m=m.next;
            p=p.next;
        }
        return dummy.next;
    }
}
```

# 树

## 94 二叉树中序遍历 hot100

```java
class Solution {

    private List<Integer> ans=new ArrayList<>();
    public void dfs(TreeNode p){
        if(p==null){
            return;
        }

        dfs(p.left);
        ans.add(p.val);
        dfs(p.right);
    }

    public List<Integer> inorderTraversal(TreeNode root) {
        dfs(root);
        return ans;
    }
}
```

## 104 二叉树最大深度 hot100

```java
class Solution {

    int maxDep=0;
    public void dfs(TreeNode p,int dep){
        if(p==null){
            return;
        }
        maxDep=Math.max(maxDep,dep);
        dfs(p.left,dep+1);
        dfs(p.right,dep+1);
    }

    public int maxDepth(TreeNode root) {
        dfs(root,1);
        return maxDep;
    }
}
```

## 226 翻转二叉树 hot100

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null){
            return root;
        }
        invertTree(root.left);
        invertTree(root.right);
        TreeNode temp=root.left;
        root.left=root.right;
        root.right=temp;
        return root;
    }
}
```

## 101 对称二叉树 hot100

```java
class Solution {

    public boolean check(TreeNode p,TreeNode q){
        if(p==null&&q==null){
            return true;
        }
        if((p==null)||(q==null) || (p.val!=q.val)){
            return false;
        }
        return check(p.left,q.right)&&check(p.right,q.left);
    }

    public boolean isSymmetric(TreeNode root) {
        if( (root==null) || (root.left==null&&root.right==null)){
            return true;
        }
        if( (root.left==null) || (root.right==null) || (root.left.val!=root.right.val)){
            return false;
        }
        return check(root.left,root.right);
    }
}
```

## 108 有序数组转二叉搜索树 hot100

```java
class Solution {

    public TreeNode build(int[] nums,int l,int r){
        if(l>r){
            return null;
        }
        int mid=(l+r)/2;
        TreeNode p=new TreeNode(nums[mid]);
        p.left=build(nums,l,mid-1);
        p.right=build(nums,mid+1,r);
        return p;
    }

    public TreeNode sortedArrayToBST(int[] nums) {
        return build(nums,0,nums.length-1);
    }
}
```

## 543 二叉树的直径 hot100

树形DP

```java
class Solution {
    private int ans=0;

    public int dfs(TreeNode p){
        if(p==null){
            return -1;
        }
        int l=dfs(p.left)+1;
        int r=dfs(p.right)+1;
        ans=Math.max(ans,l+r);
        return Math.max(l,r);
    }

    public int diameterOfBinaryTree(TreeNode root) {
        dfs(root);
        return ans;
    }
}
```

## 230 二叉搜索树第k小元素 hot100

```java
class Solution {
    private int T=0;
    private int ans=-1;
    public void dfs(TreeNode p){
        if(p==null||ans!=-1){
            return;
        }
        dfs(p.left);
        if(--T==0){
            ans=p.val;
        }
        dfs(p.right);
    }
    public int kthSmallest(TreeNode root, int k) {
        T=k;
        dfs(root);
        return ans;
    }
}
```



## 102 二叉树层序遍历 hot100

Node类可以用java的AbstractEntry来替代的。但是我怕到时候写题的时候实例化不出来就尴尬了）。自己写个pair类吧，不麻烦。

```java
class Solution {

    class Node{
        TreeNode p;
        int dep;
        Node(TreeNode node,int depth){
            this.p=node;
            dep=depth;
        }
    }

    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans=new ArrayList<>();
        Queue<Node> q=new ArrayDeque<>();
        q.add(new Node(root,1));
        while(!q.isEmpty()){
            Node t=q.poll();
            if(t.p==null){
                continue;
            }
            if(ans.size()<t.dep){
                ans.add(new ArrayList<>());
            }
            ans.get(t.dep-1).add(t.p.val);

            q.add(new Node(t.p.left,t.dep+1));
            q.add(new Node(t.p.right,t.dep+1));
        }
        return ans;
    }
}
```

## 98 验证二叉搜索树 hot100

```java
class Solution {

    public boolean check(TreeNode p,Integer minn,Integer maxx){
        if(p==null){
            return true;
        }
        if((maxx!=null&&p.val>=maxx)||(minn!=null&&p.val<=minn)){
            return false;
        }
        return check(p.left,minn,p.val)&&check(p.right,p.val,maxx);
    }

    public boolean isValidBST(TreeNode root) {
        return check(root,null,null);       
    }
}
```

## 199 二叉树的右视图 hot100

```java
lass Solution {
    private List<Integer> ans=new ArrayList<>();

    public void dfs(TreeNode p,int dep){
        if(p==null){
            return;
        }
        if(ans.size()<dep){
            ans.add(p.val);
        }
        dfs(p.right,dep+1);
        dfs(p.left,dep+1);
    }

    public List<Integer> rightSideView(TreeNode root) {
        dfs(root,1);
        return ans;
    }
}
```

## 114 二叉树展开为链表 hot100

偷懒做法

```java
class Solution {
    List<TreeNode> t=new ArrayList<>();

    public void dfs(TreeNode p){
        if(p==null){
            return;
        }
        t.add(p);
        dfs(p.left);
        dfs(p.right);
    }
    public void flatten(TreeNode root) {
        dfs(root);
        for(int i=0;i<t.size();++i){
            TreeNode p=t.get(i);
            p.left=null;
            p.right=null;
            if(i!=t.size()-1){
                p.right=t.get(i+1);
            }
        }
    }
}
```

## 236 二叉树最近公共祖先 hot100

```java
class Solution {

    Map<TreeNode,TreeNode> fa=new HashMap<>();
    Map<TreeNode,Integer> dep=new HashMap<>();

    public void dfs(TreeNode p,TreeNode F,int D){
        if(p==null){
            return;
        }
        fa.put(p,F);
        dep.put(p,D);
        dfs(p.left,p,D+1);
        dfs(p.right,p,D+1);
    }

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        dfs(root,null,1);

        //让p在最深
        if(dep.get(p)<dep.get(q)){
            TreeNode temp=q;
            q=p;
            p=temp;
        }

        while(dep.get(p)>dep.get(q)){
            p=fa.get(p);
        }

        while(p!=q){
            p=fa.get(p);
            q=fa.get(q);
        }
        return p;
    }
}
```



# 普通数组 hot100

## 53 最大子数组和 hot100

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int ans=Integer.MIN_VALUE;
        int sum=0;
        for(int i=0;i<nums.length;++i){
            sum=Math.max(0,sum)+nums[i];
            ans=Math.max(ans,sum);
        }

        return ans;
    }
}
```

## 189 轮转数组 hot100

```java
class Solution {

    private void swap(int[] nums,int a,int b){
        int temp=nums[a];
        nums[a]=nums[b];
        nums[b]=temp;
    }

    private void reverse(int[] nums,int l,int r){
        while(l<r){
            swap(nums,l,r);
            ++l;--r;
        }
    }

    public void rotate(int[] nums, int k) {
        k%=nums.length;
        reverse(nums,0,nums.length-1);
        reverse(nums,0,k-1);
        reverse(nums,k,nums.length-1);
    }
}
```

## 238 除自身以外数组乘积 hot100

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n=nums.length;
        int[] ans=new int[n];

        int mul=1;
        for(int i=0;i<n;++i){
            ans[i]=mul;
            mul*=nums[i];
        }

        mul=1;
        for(int i=n-1;i>=0;--i){
            ans[i]*=mul;
            mul*=nums[i];
        }

        return ans;
    }
}
```

## 56 合并区间 hot100

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        List<int[]> ans=new ArrayList<>();

        Arrays.sort(intervals,(a,b)->Integer.compare(a[0],b[0]));

        for(int i=0;i<intervals.length;++i){
            if(ans.isEmpty()||ans.get(ans.size()-1)[1]<intervals[i][0]){
                ans.add(new int[]{intervals[i][0],intervals[i][1]});
            }else{
                ans.get(ans.size()-1)[1]=Math.max(ans.get(ans.size()-1)[1],intervals[i][1]);
            }
        }
        int[][] ansArray=new int[ans.size()][];
        for(int i=0;i<ans.size();++i){
            ansArray[i]=ans.get(i);
        }
        return ansArray;
    }
}
```

## 41 缺失的第一个正数 hot100

```java
class Solution {
    private void swap(int[] nums,int l,int r){
        int temp=nums[l];
        nums[l]=nums[r];
        nums[r]=temp;
    }

    public int firstMissingPositive(int[] nums) {
        int n=nums.length;
        for(int i=0;i<n;++i){
            if(nums[i]<1||nums[i]>n){
                //直接排除
                nums[i]=n+1;
            }
        }

        for(int i=0;i<n;++i){
            //nums[i]应该放在i位置
            while(nums[i]!=n+1&&nums[i]!=nums[nums[i]-1]){
                swap(nums,i,nums[i]-1);
            }
        }

        for(int i=0;i<n;++i){
            if(nums[i]!=i+1){
                return i+1;
            }
        }
        return n+1;
    }
}
```

# 哈希表

## 1 两数之和 hot100

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> m=new HashMap<>();
        for(int i=0;i<nums.length;++i){
            Integer pos=m.get(target-nums[i]);
            if(pos!=null){
                return new int[] {pos,i};
            }
            m.put(nums[i],i);
        }
        return null;
    }
}
```

## 128 最长连续序列 hot100

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> s=new HashSet<>();
        for(int i=0;i<nums.length;++i){
            s.add(nums[i]);
        }

        int ans=0;
        for(Integer item:s){
            //不是最佳的序列开始
            if(s.contains(item-1)){
                continue;
            }
            int len=0;
            int num=item;
            while(s.contains(num)){
                ++len;
                ++num;
            }
            ans=Math.max(ans,len);
        }

        return ans;
    }
}
```

## 49 字母异位词分组 hot100

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String,List<String>> m=new HashMap<>();

        for(int i=0;i<strs.length;++i){
            char[] s=strs[i].toCharArray();
            Arrays.sort(s);

            String str=new String(s);
            
            List<String> list=m.get(str);
            if(list==null){
                list=new LinkedList<>();
            }
            list.addLast(strs[i]);
            m.put(str,list);
        }

        return new ArrayList<>(m.values());
    }
}
```





## 560 和为k的子数组 hot100

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int ans=0;
        Map<Integer,Integer> m=new HashMap<>();

        int sum=0;
        m.put(0,1);
        for(int i=0;i<nums.length;++i){
            sum+=nums[i];
            ans+=m.getOrDefault(sum-k,0);
            if(m.get(sum)==null){
                m.put(sum,1);
            }else{
                m.put(sum,m.get(sum)+1);
            }
        }

        return ans;
    }
}
```

# 固定长度窗口

## 239 滑动窗口最大值 hot100

单调队列板子题

当有人比你小还比你强，你可以退役了。

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {

        Deque<Integer> q=new ArrayDeque<>();
        int[] ans=new int [nums.length-k+1];

        for(int i=0;i<nums.length;++i){
            while(!q.isEmpty() && nums[q.getLast()]<=nums[i]){
                q.removeLast();
            }
            while(!q.isEmpty()&&q.getFirst()<i-k+1){
                q.removeFirst();
            }

            q.addLast(i);

            if(i-k+1>=0){
                ans[i-k+1]=nums[q.getFirst()];
            }
        }

        return ans;
    }
}
```

# 栈

##  232 双栈模拟队列

用一个栈作为缓冲，反转弹出顺序罢了

```java
class MyQueue {

    Deque<Integer> input;
    Deque<Integer> output;

    public MyQueue() {
        input=new ArrayDeque<>();
        output=new ArrayDeque<>();
    }
    
    public void push(int x) {
        input.add(x);
    }
    
    public int pop() {
        if(output.isEmpty()){
            transfer();
        }
        return output.poll();
    }
    
    public int peek() {
        if(output.isEmpty()){
            transfer();
        }
        return output.peek();
    }
    
    public boolean empty() {
        return input.isEmpty()&&output.isEmpty();
    }

    private void  transfer(){
        while(!input.isEmpty()){
            output.add(input.poll());
        }
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```



# 单调栈

## 42 接雨水 hot100

```java
class Solution {
    public int trap(int[] height) {
        int n=height.length;

        int[] sufMax=new int[n];
        int[] preMax=new int[n];

        preMax[0]=height[0];
        for(int i=1;i<n;++i){
            preMax[i]=Math.max(preMax[i-1],height[i]);
        }

        sufMax[n-1]=height[n-1];
        for(int i=n-2;i>=0;--i){
            sufMax[i]=Math.max(sufMax[i+1],height[i]);
        }

        int ans=0;
        for(int i=1;i<n-1;++i){
            ans+=Math.min(sufMax[i],preMax[i])-height[i];
        }
        return ans;
    }
}
```



# 队列

## 225 队列模拟栈

吃饱了没事干的题

```java
class MyStack {

    private Queue<Integer> q;

    public MyStack() {
        q=new LinkedList<Integer>();
    }
    
    public void push(int x) {
        q.add(x);
    }
    
    public int pop() {
        int x=q.size();
        while(--x>0){
            q.add(q.poll());
        }
        return q.poll();
    }
    
    public int top() {
        int x=q.size();
        while(--x>0){
            q.add(q.poll());
        }
        int temp=q.peek();
        q.add(q.poll());
        return temp;
    }
    
    public boolean empty() {
        return q.isEmpty();
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */
```



# 单调队列



# 双指针/滑动窗口

常见的就是维护两个l和r区间。题目一般会要求区间具有某种性质，然后在这个性质下找到最长或者最短的区间。

一般就是枚举左边界，然后在枚举右边界，n方判断这个区间是否符合性质，然后更新答案。



上面的枚举说明了当区间的左端点或者右端点固定时，必然存在一个临界点，以这个点为边界，左右两边一般是符合或者不符合。并且这种临界点可能是有单调性的，比如左端点左移，那么这个临界点一般会右移或者不动。但是要是左移那就奇了怪了。什么鬼题（好像可以直接二分？）。

但是二分是不连续的，而这种性质一般涉及到区间统计，是连续的，这就需要我们类似滑动区间，毛毛虫蠕动的思想来维护区间统计信息。如果是不连续，可能真的是二分吧。



抓住这个题目要求的区间性质来分析,判断存不存在连续的区间统计，这样可以通过移动双指针同时修改区间统计信息，实现O(n)的计算，每次都卡在那个临界点。



## 76 最小覆盖子串 hot100

```java
class Solution {
    
    public String minWindow(String s, String t) {
        int ansl=-1;
        int ansr=-1;

        int[] need=new int[300];
        int count=0;
        
        for(int i=0;i<t.length();++i){
            if(need[t.charAt(i)]==0){
                ++count;
            }
            ++need[t.charAt(i)];
        }
        int l=0;
        for(int r=0;r<s.length();++r){

            --need[s.charAt(r)];
            if(need[s.charAt(r)]==0){
                --count;
            }
            while(l<=r&&count==0){
                if(ansl==-1 || ansr-ansl>r-l){
                    ansl=l;
                    ansr=r;
                }
                if(need[s.charAt(l)]==0){
                    ++count;
                }
                ++need[s.charAt(l)];
                ++l;
            }
        }

        if(ansl!=-1){
            return s.substring(ansl,ansr+1);
        }else {
            return "";
        }
    }
}
```

## 15 三数之和 hot100

排序后暴力的枚举

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans=new ArrayList<>();
        Arrays.sort(nums);

        for(int i=0;i<nums.length-2;++i){
            //去重
            if(i!=0&&nums[i]==nums[i-1]){
                continue;
            }
            int l=i+1;
            int r=nums.length-1;
            while(l<r){
                if(nums[i]+nums[l]+nums[r]<0) {
                    ++l;
                }
                else if(nums[i]+nums[l]+nums[r]>0) {
                    --r;
                }
                else if(nums[i]+nums[l]+nums[r]==0){
                    List<Integer> a=new ArrayList<>();
                    a.add(nums[i]);
                    a.add(nums[l]);
                    a.add(nums[r]);
                    ans.add(a);
                    ++l;--r;
                    while(l<r&&nums[l]==nums[l-1]) {
                        ++l;
                    }
                    while(l<r&&nums[r]==nums[r+1]) {
                        --r;
                    }
                }

            }
        }

        return ans;
    }
}
```



## 283 移动零 hot100

```java
class Solution {

    private void swap(int[] nums,int l,int r){
        int temp=nums[l];
        nums[l]=nums[r];
        nums[r]=temp;
    }

    public void moveZeroes(int[] nums) {
        int l=0;
        for(int r=0;r<nums.length;++r){
            if(nums[r]!=0){
                swap(nums,l,r);
                ++l;
            }
        }
    }
}
```

## 11 盛最多水的容器 hot100

```java
class Solution {

    public int maxArea(int[] height) {
        int n=height.length;

        int l=0;
        int r=n-1;

        int ans=(r-l)*Math.min(height[l],height[r]);

        while(l<r){
            if(height[l]<=height[r]){
                ++l;
            }else{
                --r;
            }
            ans=Math.max((r-l)*Math.min(height[l],height[r]),ans);
        }
        return ans;
    }
}
```

## 3 无重复字符的最长子串

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int ans=0;
        char[] str=s.toCharArray();

        int l=0;
        int[] count=new int [260];

        for(int r=0;r<str.length;++r){
            ++count[str[r]];

            while(l<r&&count[str[r]]>1){
                --count[str[l]];
                ++l;
            }
            
            ans=Math.max(ans,r-l+1);
        }


        return ans;
    }
}
```



# 字符串

## 5 最长回文子串 hot100
```java
class Solution {
    public String longestPalindrome(String s) {
        int n=s.length();

        int ansl=-1;
        int ansr=-1;

        //假设是奇数长度的回文串
        for(int i=0;i<n;++i){
            int l=i;
            int r=i;
            while(l>=0&&r<n&&s.charAt(l)==s.charAt(r)){
                if(r-l>ansr-ansl || ansl==-1){
                    ansl=l;
                    ansr=r;
                }
                l--;
                ++r;
            }
        }

        //假设是偶数长度的回文串
        for(int i=0;i<n-1;++i){
            int l=i;
            int r=i+1;
            while(l>=0&&r<n&&s.charAt(l)==s.charAt(r)){
                if(r-l>ansr-ansl|| ansl==-1){
                    ansl=l;
                    ansr=r;
                }
                l--;
                ++r;
            }
        }
        return ansl==-1 ? "" : s.substring(ansl,ansr+1);
    }
}
```



# 动态规划

## 70 爬楼梯 hot100

```java
class Solution {
    public int climbStairs(int n) {
        
        //需要特判，不然初始化会出界
        if(n==1){
            return 1;
        }
        if(n==2){
            return 2;
        }

        int[] f=new int [n+1];

        f[1]=1;
        f[2]=2;

        for(int i=3;i<=n;++i){
            f[i]=f[i-1]+f[i-2];
        }

        return f[n];
    }
}
```

## 118 杨辉三角 hot100

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> ans=new ArrayList<>();

        for(int i=0;i<numRows;++i){
            List<Integer> row=new ArrayList<>();
            for(int j=0;j<=i;++j){
                if(j==0||j==i){
                    row.add(1);
                }else{
                    row.add(ans.get(i-1).get(j)+ans.get(i-1).get(j-1));
                }
            }
            ans.add(row);
        }
        
        return ans;
    }
}
```



## 198 打家劫舍 hot 100

```java
class Solution {
    public int rob(int[] nums) {
        int n=nums.length;

        if(n==1){
            return nums[0];
        }
        else if(n==2){
            return Math.max(nums[0],nums[1]);
        }

        int[] f=new int [n];
        
        f[0]=nums[0];f[1]=Math.max(nums[0],nums[1]);
        for(int i=2;i<n;++i){
            f[i]=Math.max(f[i-1],f[i-2]+nums[i]);
        }

        return f[n-1];
    }
}
```

## 279 完全平方数 hot100

```java
class Solution {
    //完全背包

    private int[][] f=new int[101][10007];

    public int numSquares(int n) {
        
        Arrays.fill(f[0],Integer.MAX_VALUE);
        f[0][0]=0;

        for(int i=1;i*i<=n;++i){
            int square=i*i;
            for(int j=0;j<=n;++j){
                if(j<square){
                    // 不选当前平方数：继承上一层状态
                    f[i][j] = f[i-1][j];
                }else{
                    f[i][j] = Math.min(f[i-1][j], f[i][j - square] + 1);
                }
            }
        }

        return f[(int) Math.sqrt(n)][n];
    }
}
```

## 322 零钱兑换 hot100

还是完全背包

```java
class Solution {
    private int[][] f=new int[13][10007];
    public int coinChange(int[] coins, int amount) {
        int n=coins.length;
        Arrays.fill(f[0],Integer.MAX_VALUE/2);
        f[0][0]=0;

        for(int i=0;i<n;++i){
            for(int j=0;j<=amount;++j){
                if(i>0){
                    f[i][j]=f[i-1][j];
                }
                if(j>=coins[i]){
                    f[i][j]=Math.min(f[i][j],f[i][j-coins[i]]+1);
                }
            }
        }
        
        return f[n-1][amount]== Integer.MAX_VALUE/2? -1: f[n-1][amount];
    }
}
```

## 62 不同路径 hot100

简单的递推

```java
class Solution {
    private int[][] f;
    public int uniquePaths(int m, int n) {
        f=new int[m][n];

        if(m<=1||n<=1){
            return 1;
        }

        f[0][0]=1;
        for(int i=0;i<m;++i){
            f[i][0]=1;
        }
        for(int j=0;j<n;++j){
            f[0][j]=1;
        }


        for(int i=1;i<m;++i){
            for(int j=1;j<n;++j){
                f[i][j]=f[i][j-1]+f[i-1][j];
            }
        }

        return f[m-1][n-1];
    }
}
```

## 64 最小路径和 hot100

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int n=grid.length;
        int m=grid[0].length;

        int[][] f=new int[n][m];
        for(int i=0;i<n;++i){
            Arrays.fill(f[i],Integer.MAX_VALUE/2);
        }
        f[0][0]=grid[0][0];

        for(int i=0;i<n;++i){
            for(int j=0;j<m;++j){
                if(i!=0){
                    f[i][j]=Math.min(f[i][j],f[i-1][j]+grid[i][j]);
                }
                if(j!=0){
                    f[i][j]=Math.min(f[i][j],f[i][j-1]+grid[i][j]);
                }
            }
        }

        return f[n-1][m-1];
    }
}
```

## 1143 最长公共子序列 hot100

```java
class Solution {

    public int longestCommonSubsequence(String text1, String text2) {
        int n=text1.length();
        int m=text2.length();
        char[] s=text1.toCharArray();
        char[] t=text2.toCharArray();

        int[][] f=new int[n+1][m+1];
        for(int i=1;i<=n;++i){
            for(int j=1;j<=m;++j){
                f[i][j]=Math.max(f[i-1][j],f[i][j-1]);
                if(s[i-1]==t[j-1]){
                    f[i][j]=Math.max(f[i][j],f[i-1][j-1]+1);
                }
            }
        }

        return f[n][m];
    }
}
```

## 72 编辑距离 hot100

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int n=word1.length();
        int m=word2.length();
        char[] s=word1.toCharArray();
        char[] t=word2.toCharArray();

        int f[][]=new int[n+1][m+1];

        for(int i=1;i<=n;++i){
            f[i][0]=i;
        }
        for(int j=1;j<=m;++j){
            f[0][j]=j;
        }

        for(int i=1;i<=n;++i){
            for(int j=1;j<=m;++j){
                //相同，不用操作
                if(s[i-1]==t[j-1]){
                    f[i][j]=f[i-1][j-1];
                }else{
                    //删除一个字符 f[i][j-1]
                    //替换一个字符 f[i-1][j-1]
                    //插入一个字符 f[i-1][j]
                    f[i][j]=Math.min(f[i-1][j],Math.min(f[i][j-1],f[i-1][j-1]))+1;   
                }
            }
        }


        return f[n][m];
    }
}
```

## 139 单词划分 hot100

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> set=new HashSet<>();
        for(String str:wordDict){
            set.add(str);
        }

        int n=s.length();
        boolean[] f=new boolean[n+1];
        f[0]=true;

        for(int i=1;i<=n;++i){
            //枚举切割点 1---j  j+1----i
            for(int j=0;j<i;++j){
                if(f[j]&&set.contains(s.substring(j,i) )){
                    f[i]=true;
                    break;
                }
            }
        }

        return f[n];
    }
}
```

## 416 分割等和子集 hot100

 都是正整数，状态表示简单，可以用背包，如果有负数的话，影响转移方向，很难确保只选一次。

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int n=nums.length;
        int sum=0;

        for(int i=0;i<n;++i){
            sum+=nums[i];
        }

        if(sum%2!=0){
            return false;
        }

        int target=sum/2;

        boolean[] f=new boolean[target+7];
        f[0]=true;
        for(int i=0;i<n;++i){
            //倒序，因为一个元素只能用一次
            for(int j=target;j>=nums[i];--j){
                f[j] |= f[j-nums[i]];
            }
        }

        return f[target];
    }
}
```

## 32 最长有效括号 hot100

luogu也有这题，但是黄题），并且还要输出答案串,还有两种括号。


括号匹配，需要的是就近原则。而栈后进先出就符合了这个要求

```java
import java.util.*;
class Solution {
    public int longestValidParentheses(String s) {
        int n=s.length();
        char[] str=s.toCharArray();
        boolean[] match=new boolean[n+1];

        Deque<Integer> stack=new ArrayDeque<>();
        for(int i=0;i<n;++i){
            if(str[i]=='('){
                stack.push(i);
            }

            else if(str[i]==')'&&!stack.isEmpty()){
                int left=stack.pop();
                match[left]=true;
                match[i]=true;
            }
            
        }

        int ans=0;
        int count=0;
        for(int i=0;i<n;++i){
            if(match[i]==true){
                ++count;
            }else{
                ans=Math.max(ans,count);
                count=0;
            }
        }
        ans=Math.max(ans,count);
        return ans;
    }
}
```



感觉不像动态规划），就是简单的向右递推。

```java
class Solution {
    public int longestValidParentheses(String s) {
        int n=s.length();
        char[] str=s.toCharArray();
    
        int ans=0;
        //f[i]表示以str[i]为结尾的最长括号序列长度
        int[] f=new int[n];

        for(int i=1;i<n;++i){
            if(str[i]=='('){
                continue;
            }

            int left=i-1-f[i-1];
            
            //i和i-1-f[i-1]匹配上了，答案累加2
            if(left>=0&&str[left]=='('){
                f[i]=f[i-1]+2;
                //尝试和前面已经匹配的括号序列，看能不能连接上
                if(left-1>=0){
                    f[i]+=f[left-1];
                }
            }
            ans=Math.max(f[i],ans);
        }

        return ans;
    }
}
```

## 152 乘积最大子数组 hot100

```java
class Solution {
    public int maxProduct(int[] nums) {
        int n=nums.length;

        if(n==1){
            return nums[0];
        }
        
        int[] maxx=new int[n];
        int[] minn=new int[n];
        int ans;

        ans=maxx[0]=minn[0]=nums[0];

        for(int i=1;i<n;++i){
            maxx[i]=Math.max(Math.max(maxx[i-1]*nums[i],minn[i-1]*nums[i]),nums[i]);
            minn[i]=Math.min(Math.min(maxx[i-1]*nums[i],minn[i-1]*nums[i]),nums[i]);
            ans=Math.max(ans,maxx[i]);
        }
        return ans;
    }
}
```

# 矩阵

## 73 矩阵置零 hot100

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int n=matrix.length;
        int m=matrix[0].length;

        BitSet b1=new BitSet(n);
        BitSet b2=new BitSet(m);

        for(int i=0;i<n;++i){
            for(int j=0;j<m;++j){
                if(matrix[i][j]==0){
                    b1.set(i);
                    b2.set(j);
                }
            }
        }
        
        for(int i=0;i<n;++i){
            for(int j=0;j<m;++j){
                if(b1.get(i) || b2.get(j)){
                    matrix[i][j]=0;
                }
            }
        }
    }
}
```

## 240 搜索二维矩阵 hot100

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int n=matrix.length;
        int m=matrix[0].length;

        int i=0,j=m-1;
        while(i<n&&j>=0){
            if(matrix[i][j]==target) return true;

            if(matrix[i][j]>target) --j;
            
            else if(matrix[i][j]<target) ++i;
        }

        return false;
    }
}
```

## 48 旋转图形 hot100

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n=matrix.length;
        
        for(int i=0;i<n;++i){
            for(int j=0;j<i;++j){
                int temp=matrix[j][i];
                matrix[j][i]=matrix[i][j];
                matrix[i][j]=temp;
            }
        }

        for(int[] row:matrix ){
            for(int j=0;j<n/2;++j){
                int temp=row[j];
                row[j]=row[n-j-1];
                row[n-j-1]=temp;
            }
        }
    }
}
```

## 54 螺旋矩阵 hot100

```java
class Solution {
    private static int[][] d={{0,1},{1,0},{0,-1},{-1,0}};

    public List<Integer> spiralOrder(int[][] matrix) {
        int n=matrix.length;
        int m=matrix[0].length;

        List<Integer> ans=new ArrayList<>();
        boolean[][] vis =new boolean [n][m];

        int i=0;
        int j=0;
        int dir=0;

        int k=m*n;
        while(k-->0){
            ans.add(matrix[i][j]);
            vis[i][j]=true;

            int x=i+d[dir][0];
            int y=j+d[dir][1];
            if(x>=n||y>=m||x<0||y<0||vis[x][y]){
                dir=(dir+1)%4;
            }

            i=i+d[dir][0];
            j=j+d[dir][1];
        }

        return ans;
    }
}
```



