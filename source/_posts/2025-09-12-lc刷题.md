---
title: lc刷题
date: 2025-09-12 22:22:04
tags:
  - 刷题
---


# 链表

## 234回文链表 hot100

找中间节点，然后翻转后半链表，然后首尾同时向中间跳咯

```java
class Solution {

    public ListNode reverseList(ListNode head){
        ListNode prev=null;
        ListNode p =head;
        while(p!=null){
            ListNode next =p.next;

            p.next=prev;
            prev=p;
            p=next;
        }

        return prev;
        
    }

    //快慢指针 奇数找正中间，偶数找正中间偏右的
    //while里面的条件是怎么回事？  笨蛋，这两个不判断下面不就可能会NPE吗
    public ListNode findMid(ListNode head){
        ListNode slow=head;
        ListNode fast=head;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
        }
        return slow;
    }
    //翻转后，tail的尽头的null，但是head的尽头是连着tail的尾节点
    public boolean isPalindrome(ListNode head) {
        ListNode tail = reverseList(findMid(head));
        while(tail!=null){
            if(tail.val!=head.val){
                return false;
            }
            tail=tail.next;
            head=head.next;
        }
        return true;
    }
}
```

## 141 环形链表 hot100

快慢指针

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        
        if(head==null){
            return false;
        }

        ListNode slow=head;
        ListNode fast=head;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(fast==slow){
                return true;
            }
        }

        return false;
    }
}
```

## 142 环形链表二 hot100

快慢指针加一个简单的数学证明（
```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        
        if(head==null){
            return null;
        }

        ListNode slow=head;
        ListNode fast=head;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            //找到了环了
            if(fast==slow){

                while(head!=slow){
                    head=head.next;
                    slow=slow.next;
                }
                return head;
            }
        }

        return null;
    }
}
```



## 21 合并两个有序链表 hot100

就合并。while如果改成逻辑与的话可以抽离部分逻辑出来，比较好看，变成三个while

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy=new ListNode(-1,null);
        ListNode p=dummy;
        ListNode pA=list1;
        ListNode pB=list2;
        while(pA!=null||pB!=null){
            if(pA==null){
                p.next=new ListNode(pB.val,null);
                p=p.next;
                pB=pB.next;
            }else if(pB==null){
                p.next=new ListNode(pA.val,null);
                p=p.next;
                pA=pA.next;
            }else{
                if(pA.val>=pB.val){
                    p.next=new ListNode(pB.val,null);
                    p=p.next;
                    pB=pB.next;
                }else{
                    p.next=new ListNode(pA.val,null);
                    p=p.next;
                    pA=pA.next;
                }
            }
        }


        return dummy.next;
    }
}
```

## 24 两两交换链表中的节点 hot100

两两拆出来交换就行了。

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy=new ListNode(-1,head);
        ListNode p=dummy;
        while(p.next!=null&&p.next.next!=null){
            ListNode first=p.next;
            ListNode second=p.next.next;
            ListNode three=p.next.next.next;

            p.next=second;
            second.next=first;
            first.next=three;

            p=first;
        }        
        return dummy.next;
    }
}
```

## 2 两数相加 hot100

类似于合并链表

代码优化，总是保证p1是长的那条，减少代码量

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy=new ListNode(-1,null);
        ListNode p1=l1;
        ListNode p2=l2;
        ListNode p=dummy;
        int cnt=0;
        while(p1!=null||p2!=null){
            if(p1==null&&p2!=null){
                p1=p2;
                p2=null;
            }
            int a=p1.val;
            int b=p2==null ? 0:p2.val;

            int sum=a+b+cnt;
            p.next=new ListNode(sum%10,null);
            p=p.next;

            p1=p1.next;
            p2=p2==null? null:p2.next;

            cnt=sum/10;
        }
        if(cnt!=0){
            p.next=new ListNode(cnt,null);
            p=p.next;
        }

        return dummy.next;
    }
}
```

## 23 合并K个升序链表 hot100

用堆动态维护链表集合的头部就行了。

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> q=new PriorityQueue<ListNode>((a,b)-> a.val-b.val );

        for(int i=0;i<lists.length;++i){
            if(lists[i]!=null){
                q.add(lists[i]);
            }
        }

        ListNode dummy=new ListNode(-1,null);
        ListNode p=dummy;

        while(!q.isEmpty()){
            ListNode t=q.poll();

            p.next=new ListNode(t.val,null);
            p=p.next;

            if(t.next!=null){
                q.add(t.next);
            }
        }

        return dummy.next;
    }
}
```

## 19 删除链表倒数第n个节点 hot100

快慢指针

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {

        //可能会删除头节点，因此引入哨兵节点
        ListNode dummy=new ListNode(-1,head);

        ListNode fast=dummy;
        ListNode slow=dummy;

        for(int i=1;i<=n;++i){
            fast=fast.next;
        }
        while(fast.next!=null){
            fast=fast.next;
            slow=slow.next;
        }

        slow.next=slow.next.next;
        return dummy.next;
    }
}
```

## 25 K个一组翻转链表 hot100

```java
class Solution {

    public ListNode[] reverseList(ListNode head){
        ListNode tail=head;

        ListNode cur=head;
        ListNode prev=null;

        while(cur!=null){
            ListNode next=cur.next;

            cur.next=prev;

            prev=cur;
            cur=next;
        }

        return new ListNode[]{prev,tail};
    }

    public ListNode reverseKGroup(ListNode head, int k) {
        int cnt=0;
        
        ListNode dummy=new ListNode(0,head);
        ListNode p=dummy.next;
        ListNode prev=dummy;

        //类似双指针的思想吧，prev---p之间就是要反转的k个链表
        while(p!=null){
            ++cnt;
            if(cnt==k){
                
                //断开连接
                ListNode next=p.next;
                p.next=null;
                
                //新链表 t[1]<------t[0]    主链表是 prev---->p 这个方向
                ListNode[] t=reverseList(prev.next);

                prev.next=t[0];
                t[1].next=next;

                prev=t[1];
                p=next;
                cnt=0;
            }else{
                p=p.next;
            }
        }
        return dummy.next;
    }
}
```

## 138 随机链表的复制 hot100

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    //总体思路就是在原链表的里塞入新链表，然后最后拆分出来
    public Node copyRandomList(Node head) {
        
        if(head==null){
            return null;
        }

        //第一遍，直接在原链表基础上增生一遍
        for(Node p=head;p!=null;p=p.next.next){
            Node next=p.next;
            p.next=new Node(p.val);
            p.next.next=next;
        }

        //第二遍，确认新链表的random指针
        for(Node p=head;p!=null;p=p.next.next){
            Node q=p.next;
            if(p.random!=null){
                q.random=p.random.next;
            }
        }

        //第三遍，拆分出新链表,两两一对拆分
        Node ans=head.next;
        for(Node p=head,q=ans;p!=null;){
            Node nextp=p.next.next;
            Node nextq=q.next==null ? null:q.next.next;

            p.next=nextp;
            q.next=nextq;

            p=nextp;
            q=nextq;
        }
        return ans;
    }
}
```

## 146 LRU缓存 hot100

```java
class LRUCache {

    class Node{
        int key;
        int val;
        Node next;
        Node prev;
        Node(int K,int V){
            key=K;
            val=V;
            prev=null;
            next=null;
        }
    }

    int cap;
    Node dummy;//循环链表
    Map<Integer,Node> m=new HashMap<>();

    public LRUCache(int capacity) {
        cap=capacity;
        dummy=new Node(-1,-1);
        dummy.prev=dummy;
        dummy.next=dummy;
    }
    
    public int get(int key) {
        Node t=m.get(key);
        if(t==null){
            return -1;
        }
        remove(t);
        addToFront(t);
        return t.val;
    }
    
    public void put(int key, int value) {
        Node t=m.get(key);
        //不存在，则插入
        if(t==null){
            Node newNode=new Node(key,value);
            m.put(key,newNode);
            addToFront(newNode);
            if(m.size()==cap+1){
                m.remove(dummy.prev.key);
                remove(dummy.prev);            
            }
        }else{
            t.val=value;
            remove(t);
            addToFront(t);
        }
    }

    private void remove(Node p){
        p.next.prev=p.prev;
        p.prev.next=p.next;
        p.next=null;
        p.prev=null;
    }

    private void addToFront(Node f){
        Node head=dummy.next;

        head.prev=f;
        f.next=head;

        dummy.next=f;
        f.prev=dummy;
    }
}
```

## 148 排序链表 hot100

链表不能随机访问，只能局部访问，显然是归并了吧。

显然没必要那么多new的，但是为了方便就这样吧。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    //归并排序链表板
    public ListNode sortList(ListNode head) {
        if(head==null||head.next==null){
            return head;
        }
        ListNode mid=findMid(head);
        ListNode l=sortList(head);
        ListNode r=sortList(mid);
        return merge(l,r);
    }

    private ListNode findMid(ListNode head){
        ListNode fast=head;
        ListNode slow=head;
        ListNode prev=null;
        while(fast!=null&&fast.next!=null){
            prev=slow;
            fast=fast.next.next;
            slow=slow.next;
        }
        prev.next=null;
        return slow;
    }

    private ListNode merge(ListNode l1,ListNode l2){
        ListNode dummy=new ListNode(-1,null);
        ListNode p=dummy;
        ListNode n=l1;
        ListNode m=l2;
        while(n!=null&&m!=null){
            if(n.val<=m.val){
                p.next=new ListNode(n.val);
                n=n.next;
            }else{
                p.next=new ListNode(m.val);
                m=m.next;
            }
            p=p.next;
        }
        while(n!=null){
            p.next=new ListNode(n.val);
            n=n.next;
            p=p.next;
        }
        while(m!=null){
            p.next=new ListNode(m.val);
            m=m.next;
            p=p.next;
        }
        return dummy.next;
    }
}
```

# 树

## 94 二叉树中序遍历 hot100

```java
class Solution {

    private List<Integer> ans=new ArrayList<>();
    public void dfs(TreeNode p){
        if(p==null){
            return;
        }

        dfs(p.left);
        ans.add(p.val);
        dfs(p.right);
    }

    public List<Integer> inorderTraversal(TreeNode root) {
        dfs(root);
        return ans;
    }
}
```

## 104 二叉树最大深度 hot100

```java
class Solution {

    int maxDep=0;
    public void dfs(TreeNode p,int dep){
        if(p==null){
            return;
        }
        maxDep=Math.max(maxDep,dep);
        dfs(p.left,dep+1);
        dfs(p.right,dep+1);
    }

    public int maxDepth(TreeNode root) {
        dfs(root,1);
        return maxDep;
    }
}
```

## 226 翻转二叉树 hot100

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null){
            return root;
        }
        invertTree(root.left);
        invertTree(root.right);
        TreeNode temp=root.left;
        root.left=root.right;
        root.right=temp;
        return root;
    }
}
```

## 101 对称二叉树 hot100

```java
class Solution {

    public boolean check(TreeNode p,TreeNode q){
        if(p==null&&q==null){
            return true;
        }
        if((p==null)||(q==null) || (p.val!=q.val)){
            return false;
        }
        return check(p.left,q.right)&&check(p.right,q.left);
    }

    public boolean isSymmetric(TreeNode root) {
        if( (root==null) || (root.left==null&&root.right==null)){
            return true;
        }
        if( (root.left==null) || (root.right==null) || (root.left.val!=root.right.val)){
            return false;
        }
        return check(root.left,root.right);
    }
}
```

## 108 有序数组转二叉搜索树 hot100

```java
class Solution {

    public TreeNode build(int[] nums,int l,int r){
        if(l>r){
            return null;
        }
        int mid=(l+r)/2;
        TreeNode p=new TreeNode(nums[mid]);
        p.left=build(nums,l,mid-1);
        p.right=build(nums,mid+1,r);
        return p;
    }

    public TreeNode sortedArrayToBST(int[] nums) {
        return build(nums,0,nums.length-1);
    }
}
```

## 543 二叉树的直径 hot100

树形DP

```java
class Solution {
    private int ans=0;

    public int dfs(TreeNode p){
        if(p==null){
            return -1;
        }
        int l=dfs(p.left)+1;
        int r=dfs(p.right)+1;
        ans=Math.max(ans,l+r);
        return Math.max(l,r);
    }

    public int diameterOfBinaryTree(TreeNode root) {
        dfs(root);
        return ans;
    }
}
```

## 230 二叉搜索树第k小元素 hot100

```java
class Solution {
    private int T=0;
    private int ans=-1;
    public void dfs(TreeNode p){
        if(p==null||ans!=-1){
            return;
        }
        dfs(p.left);
        if(--T==0){
            ans=p.val;
        }
        dfs(p.right);
    }
    public int kthSmallest(TreeNode root, int k) {
        T=k;
        dfs(root);
        return ans;
    }
}
```



## 102 二叉树层序遍历 hot100

Node类可以用java的AbstractEntry来替代的。但是我怕到时候写题的时候实例化不出来就尴尬了）。自己写个pair类吧，不麻烦。

```java
class Solution {

    class Node{
        TreeNode p;
        int dep;
        Node(TreeNode node,int depth){
            this.p=node;
            dep=depth;
        }
    }

    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans=new ArrayList<>();
        Queue<Node> q=new ArrayDeque<>();
        q.add(new Node(root,1));
        while(!q.isEmpty()){
            Node t=q.poll();
            if(t.p==null){
                continue;
            }
            if(ans.size()<t.dep){
                ans.add(new ArrayList<>());
            }
            ans.get(t.dep-1).add(t.p.val);

            q.add(new Node(t.p.left,t.dep+1));
            q.add(new Node(t.p.right,t.dep+1));
        }
        return ans;
    }
}
```

## 98 验证二叉搜索树 hot100

```java
class Solution {

    public boolean check(TreeNode p,Integer minn,Integer maxx){
        if(p==null){
            return true;
        }
        if((maxx!=null&&p.val>=maxx)||(minn!=null&&p.val<=minn)){
            return false;
        }
        return check(p.left,minn,p.val)&&check(p.right,p.val,maxx);
    }

    public boolean isValidBST(TreeNode root) {
        return check(root,null,null);       
    }
}
```

## 199 二叉树的右视图 hot100

```java
lass Solution {
    private List<Integer> ans=new ArrayList<>();

    public void dfs(TreeNode p,int dep){
        if(p==null){
            return;
        }
        if(ans.size()<dep){
            ans.add(p.val);
        }
        dfs(p.right,dep+1);
        dfs(p.left,dep+1);
    }

    public List<Integer> rightSideView(TreeNode root) {
        dfs(root,1);
        return ans;
    }
}
```

## 114 二叉树展开为链表 hot100

偷懒做法

```java
class Solution {
    List<TreeNode> t=new ArrayList<>();

    public void dfs(TreeNode p){
        if(p==null){
            return;
        }
        t.add(p);
        dfs(p.left);
        dfs(p.right);
    }
    public void flatten(TreeNode root) {
        dfs(root);
        for(int i=0;i<t.size();++i){
            TreeNode p=t.get(i);
            p.left=null;
            p.right=null;
            if(i!=t.size()-1){
                p.right=t.get(i+1);
            }
        }
    }
}
```

## 236 二叉树最近公共祖先 hot100

```java
class Solution {

    Map<TreeNode,TreeNode> fa=new HashMap<>();
    Map<TreeNode,Integer> dep=new HashMap<>();

    public void dfs(TreeNode p,TreeNode F,int D){
        if(p==null){
            return;
        }
        fa.put(p,F);
        dep.put(p,D);
        dfs(p.left,p,D+1);
        dfs(p.right,p,D+1);
    }

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        dfs(root,null,1);

        //让p在最深
        if(dep.get(p)<dep.get(q)){
            TreeNode temp=q;
            q=p;
            p=temp;
        }

        while(dep.get(p)>dep.get(q)){
            p=fa.get(p);
        }

        while(p!=q){
            p=fa.get(p);
            q=fa.get(q);
        }
        return p;
    }
}
```



# 普通数组 hot100

## 53 最大子数组和 hot100

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int ans=Integer.MIN_VALUE;
        int sum=0;
        for(int i=0;i<nums.length;++i){
            sum=Math.max(0,sum)+nums[i];
            ans=Math.max(ans,sum);
        }

        return ans;
    }
}
```

## 189 轮转数组 hot100

```java
class Solution {

    private void swap(int[] nums,int a,int b){
        int temp=nums[a];
        nums[a]=nums[b];
        nums[b]=temp;
    }

    private void reverse(int[] nums,int l,int r){
        while(l<r){
            swap(nums,l,r);
            ++l;--r;
        }
    }

    public void rotate(int[] nums, int k) {
        k%=nums.length;
        reverse(nums,0,nums.length-1);
        reverse(nums,0,k-1);
        reverse(nums,k,nums.length-1);
    }
}
```

## 238 除自身以外数组乘积 hot100

```hot100
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n=nums.length;
        int[] ans=new int[n];

        int mul=1;
        for(int i=0;i<n;++i){
            ans[i]=mul;
            mul*=nums[i];
        }

        mul=1;
        for(int i=n-1;i>=0;--i){
            ans[i]*=mul;
            mul*=nums[i];
        }

        return ans;
    }
}
```

## 56 合并区间 hot100

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        List<int[]> ans=new ArrayList<>();

        Arrays.sort(intervals,(a,b)->Integer.compare(a[0],b[0]));

        for(int i=0;i<intervals.length;++i){
            if(ans.isEmpty()||ans.get(ans.size()-1)[1]<intervals[i][0]){
                ans.add(new int[]{intervals[i][0],intervals[i][1]});
            }else{
                ans.get(ans.size()-1)[1]=Math.max(ans.get(ans.size()-1)[1],intervals[i][1]);
            }
        }
        int[][] ansArray=new int[ans.size()][];
        for(int i=0;i<ans.size();++i){
            ansArray[i]=ans.get(i);
        }
        return ansArray;
    }
}
```

41 缺失的第一个正数 hot100

```java
class Solution {
    private void swap(int[] nums,int l,int r){
        int temp=nums[l];
        nums[l]=nums[r];
        nums[r]=temp;
    }

    public int firstMissingPositive(int[] nums) {
        int n=nums.length;
        for(int i=0;i<n;++i){
            if(nums[i]<1||nums[i]>n){
                //直接排除
                nums[i]=n+1;
            }
        }

        for(int i=0;i<n;++i){
            //nums[i]应该放在i位置
            while(nums[i]!=n+1&&nums[i]!=nums[nums[i]-1]){
                swap(nums,i,nums[i]-1);
            }
        }

        for(int i=0;i<n;++i){
            if(nums[i]!=i+1){
                return i+1;
            }
        }
        return n+1;
    }
}
```

# 子串

## 560 和为k的子数组 hot100

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int ans=0;
        Map<Integer,Integer> m=new HashMap<>();

        int sum=0;
        m.put(0,1);
        for(int i=0;i<nums.length;++i){
            sum+=nums[i];
            ans+=m.getOrDefault(sum-k,0);
            if(m.get(sum)==null){
                m.put(sum,1);
            }else{
                m.put(sum,m.get(sum)+1);
            }
        }

        return ans;
    }
}
```

## 239 滑动窗口最大值 hot100

单调队列板子题

当有人比你小还比你强，你可以退役了。

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {

        Deque<Integer> q=new ArrayDeque<>();
        int[] ans=new int [nums.length-k+1];

        for(int i=0;i<nums.length;++i){
            while(!q.isEmpty() && nums[q.getLast()]<=nums[i]){
                q.removeLast();
            }
            while(!q.isEmpty()&&q.getFirst()<i-k+1){
                q.removeFirst();
            }

            q.addLast(i);

            if(i-k+1>=0){
                ans[i-k+1]=nums[q.getFirst()];
            }
        }

        return ans;
    }
}
```

## 76 最小覆盖子串 hot100

双指针扫描

```java
class Solution {
    
    public String minWindow(String s, String t) {
        int ansl=-1;
        int ansr=-1;

        int[] need=new int[300];
        int count=0;
        
        for(int i=0;i<t.length();++i){
            if(need[t.charAt(i)]==0){
                ++count;
            }
            ++need[t.charAt(i)];
        }
        int l=0;
        for(int r=0;r<s.length();++r){

            --need[s.charAt(r)];
            if(need[s.charAt(r)]==0){
                --count;
            }
            while(l<=r&&count==0){
                if(ansl==-1 || ansr-ansl>r-l){
                    ansl=l;
                    ansr=r;
                }
                if(need[s.charAt(l)]==0){
                    ++count;
                }
                ++need[s.charAt(l)];
                ++l;
            }
        }

        if(ansl!=-1){
            return s.substring(ansl,ansr+1);
        }else {
            return "";
        }
    }
}
```

